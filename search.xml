<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Ubuntu Server 新主机的初步设置</title>
    <url>/posts/7e24/</url>
    <content><![CDATA[<p>一台新 Ubuntu 服务器的配置过程。</p>
<span id="more"></span>

<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>个人比较需要的新主机设置主要包括：</p>
<ul>
<li>创建新用户并赋予 sodu 权限</li>
<li>配置免密登录（公钥登录）</li>
<li>sudo 命令免密码</li>
<li>禁止 root 登录</li>
<li>禁止密码登录</li>
</ul>
<h2 id="配置过程"><a href="#配置过程" class="headerlink" title="配置过程"></a>配置过程</h2><p>以下详述了每一个配置过程。</p>
<h3 id="创建新用户并赋予sodu权限"><a href="#创建新用户并赋予sodu权限" class="headerlink" title="创建新用户并赋予sodu权限"></a>创建新用户并赋予 sodu 权限</h3><p>创建之前先检查系统已有的用户，使用以下命令：</p>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">cat /etc/passwd |cut -d : -f 1</span><br><span class="line"><span class="comment"># cut 的参数中</span></span><br><span class="line"><span class="comment"># -d 指定分隔符</span></span><br><span class="line"><span class="comment"># -f 选则分隔之后的 field</span></span><br></pre></td></tr></tbody></table></figure>

<p>创建用户：</p>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">sudo adduser penn <span class="comment"># 相比于 useradd 命令，adduser命令使用交互式方式,更加简单。</span></span><br></pre></td></tr></tbody></table></figure>

<p>之后再查看 <code>cat /etc/passwd</code>：</p>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">penn:x:1002:1003:,,,:/home/penn:/bin/bash</span><br></pre></td></tr></tbody></table></figure>

<p>按照  <code>“:”</code> 分隔依次是：用户名，密码，用户 ID，用户组 ID，备注，用户 Home 目录，shell 命令所在目录。</p>
<p>给用户 sudo 权限：</p>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">sudo usermod -aG sudo penn</span><br></pre></td></tr></tbody></table></figure>

<h3 id="配置免密登录（公钥登录）"><a href="#配置免密登录（公钥登录）" class="headerlink" title="配置免密登录（公钥登录）"></a>配置免密登录（公钥登录）</h3><p>首先确保客户机上有密钥对，使用 <code>ssh-keygen -t rsa</code> 可以创建密钥对。密钥对可以有多个，不能同名。</p>
<p>方法一（通用方法）：</p>
<ul>
<li>进入  <code>/home/penn</code> 目录</li>
<li>切换到  <code>penn</code> 用户</li>
<li>创建  <code>.ssh</code> 目录:  <code>mkdir .ssh</code></li>
<li>创建文件  <code>authorized_keys</code>， 贴入公钥并保存</li>
</ul>
<p>之后在客户机上可以尝试使用公钥登录  <code>ssh -i .ssh/my_private_key penn@xx.xx.xx.xx</code>。</p>
<p>方法二（需要服务器能够使用密码登录）：</p>
<p>执行：<code>ssh-copy-id  -i .ssh/my_public_key penn@xx.xx.xx.xx</code>，<br>输入密码即可成功上传公钥。</p>
<h4 id="在客户机上为IP指定私钥"><a href="#在客户机上为IP指定私钥" class="headerlink" title="在客户机上为IP指定私钥"></a>在客户机上为 IP 指定私钥</h4><p>修改 ssh 配置文件  <code>~/.ssh/config</code> ，可以获得以下功能：</p>
<ul>
<li>当客户机有多个私钥时，可以对 IP（域名）指定私钥，不用每次都写完整路径</li>
<li>可以通过  <code>ssh myserver</code> 这样的别名登录，避免每次输入过长的信息</li>
</ul>
<p>编辑客户机的  <code>.ssh/config</code> 文件，写入以下配置：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">Host my_server</span><br><span class="line">    Hostname XX.XX.XX.XX</span><br><span class="line">    Port 22</span><br><span class="line">    User penn</span><br><span class="line">    IdentityFile ~/.ssh/my_private_key</span><br></pre></td></tr></tbody></table></figure>

<p>之后可以通过 <code>ssh my_server</code> 登录机器。</p>
<h3 id="sudo命令免密码"><a href="#sudo命令免密码" class="headerlink" title="sudo命令免密码"></a>sudo 命令免密码</h3><p>使用 <code>visudo</code> 命令，编辑配置文件，写入以下行：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">penn    ALL=(ALL) NOPASSWD:ALL</span><br></pre></td></tr></tbody></table></figure>

<p>可以实现 <code>penn</code> 用户使用 <code>sudo</code> 命令不需要输入密码。<br>还可以通过 <code>visudo</code> 修改用户组设置实现 sudo 用户组使用 <code>sudo</code> 命令都不需要输入密码。见下：</p>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment"># 原数据： %sudo ALL=(ALL:ALL) ALL，修改为以下：</span></span><br><span class="line">%sudo ALL=(ALL:ALL) NOPASSWD: ALL</span><br></pre></td></tr></tbody></table></figure>

<p>注意：用户的配置如果放在用户组的配置之前，可能会被用户组的配置覆盖掉。可以将这个配置稍微靠后放。</p>
<h3 id="禁止root登录，禁止密码登录，开启公钥登录，更改端口"><a href="#禁止root登录，禁止密码登录，开启公钥登录，更改端口" class="headerlink" title="禁止root登录，禁止密码登录，开启公钥登录，更改端口"></a>禁止 root 登录，禁止密码登录，开启公钥登录，更改端口</h3><p><code>sudo vim /etc/ssh/sshd_config</code></p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">Port 8022                                   # 端口</span><br><span class="line">PasswordAuthentication no                   # 禁止密码登录</span><br><span class="line">PubkeyAuthentication yes                    # 公钥登录</span><br><span class="line">AuthorizedKeysFile   .ssh/authorized_keys   # 公钥路径</span><br></pre></td></tr></tbody></table></figure>

<p>重启服务 <code>sudo systemctl restart sshd</code></p>
<h3 id="docker-命令免-sudo-前缀"><a href="#docker-命令免-sudo-前缀" class="headerlink" title="docker 命令免 sudo 前缀"></a>docker 命令免 sudo 前缀</h3><p>默认情况下，非 root 用户使用 docker 是需要加 sudo 前缀的，可以通过将用户加入 docker 用户组来免输 sudo 使用 docker 命令。</p>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">groups <span class="comment"># 查看自己的用户组</span></span><br><span class="line">sudo usermod -aG docker penn <span class="comment"># 加入docker组, 重新登录之后即可生效</span></span><br></pre></td></tr></tbody></table></figure>

<h3 id="用openssl创建CA证书"><a href="#用openssl创建CA证书" class="headerlink" title="用openssl创建CA证书"></a>用 openssl 创建 CA 证书</h3><p>写了个脚本完成一下功能：</p>
<pre><code>创建根CA.key, 再根据 根CA.key 自签名得到 根CA.crt
再利用 根CA.crt 对其他证书申请文件(service.csr)进行签发, 得到 service.crt
之后将 service.crt,service.key 分发给服务器，终端用户只需要安装 根CA.crt 即可加密访问 service。
</code></pre>
<p>为了节约篇幅，将脚本放置在 github gist 上<a href="https://gist.github.com/ppzz/90e6c86c934bed0cdadea3bf736d6628#file-openssl-generate-cab-bash">这里</a></p>
]]></content>
      <categories>
        <category>Linux</category>
        <category>Newbie</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>netcat: 读 / 写网络数据的瑞士军刀</title>
    <url>/posts/291/</url>
    <content><![CDATA[<p>用 netcat 命令实现 TCP/UDP 的数据传输。</p>
<span id="more"></span>

<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>功能</p>
<p>在 shell 脚本中通过 TCP/UDP 协议读 / 写数据。</p>
<p>例如可以实现</p>
<ul>
<li>扫描端口</li>
<li>聊天</li>
<li>文件传送</li>
<li>代理服务</li>
<li>…</li>
</ul>
<hr>
<h2 id="一些功能-demo"><a href="#一些功能-demo" class="headerlink" title="一些功能 demo"></a>一些功能 demo</h2><h3 id="端口扫描"><a href="#端口扫描" class="headerlink" title="端口扫描"></a>端口扫描</h3><p>检测机器打开的端口</p>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">nc -z -n -v  10.10.20.11  78-90</span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 输出</span></span><br><span class="line">10.10.20.11 80 (http) open</span><br></pre></td></tr></tbody></table></figure>

<ul>
<li>-z 表示连接成功之后 马上断开连接</li>
<li> -v verbose 详细输出</li>
<li> -n 表示不要使用 DNS 反向查询 IP 的域名</li>
</ul>
<h3 id="机器通信"><a href="#机器通信" class="headerlink" title="机器通信"></a>机器通信</h3><p>S,C 两台机器</p>
<ul>
<li>S: 10.10.20.11</li>
<li>C: 10.10.20.12</li>
</ul>
<p>S 机器监听端口，C 机器在 S 启动之后建立连接：</p>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment"># S</span></span><br><span class="line">nc -l -k 1567</span><br><span class="line"><span class="comment"># C</span></span><br><span class="line">nc -w 10 10.10.20.11 1567</span><br></pre></td></tr></tbody></table></figure>

<ul>
<li>-l 保持连接，并且将数据输出到 stdout，并从 stdin 读取数据</li>
<li> -k 强制待命，客户端断开之后服务器也不断开</li>
<li> -w 设置连接断开时间（秒）</li>
</ul>
<h3 id="传送文件-目录"><a href="#传送文件-目录" class="headerlink" title="传送文件/目录"></a>传送文件 / 目录</h3><h4 id="传送文件"><a href="#传送文件" class="headerlink" title="传送文件"></a>传送文件</h4><p>服务器 -&gt; 客户端：<br>S 作为服务器先启动，C 作为客户端后启动，下同</p>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment"># S</span></span><br><span class="line">nc -l 1567 &lt; some.file</span><br><span class="line"><span class="comment"># C</span></span><br><span class="line">nc 10.10.20.11 1567 &gt; some.file</span><br></pre></td></tr></tbody></table></figure>

<p>机器 C 上，较新版 nc 运行完毕之后不会断开连接，根据文档，使用下两个参数之一可以在接受完毕之后断开连接：</p>
<ul>
<li>-N  遇到 EOF 立即断开连接</li>
<li> -q 0 遇到 EOF 等待 0 秒之后断开连接</li>
</ul>
<p>但我在 ubuntu20.04 上  <code>OpenBSD netcat (Debian patchlevel 1.206-1ubuntu1)</code> 这个版本上没有测试成功。</p>
<p>客户端 -&gt; 服务器：</p>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment"># S</span></span><br><span class="line">nc -l 1567  &gt; some.file</span><br><span class="line"><span class="comment"># C</span></span><br><span class="line">nc -N  10.10.20.11 1567 &lt; dl.sh</span><br></pre></td></tr></tbody></table></figure>

<p>这里的 <code>-q</code> <code>-N</code> 参数可以正常工作</p>
<h4 id="传送目录"><a href="#传送目录" class="headerlink" title="传送目录"></a>传送目录</h4><p>服务器 -&gt; 客户端：<br>传递目录需要将目录打包成一个文件再传递</p>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment"># S</span></span><br><span class="line">tar -cvf - test-nc | nc -l 1567</span><br><span class="line"><span class="comment"># C</span></span><br><span class="line">nc 10.10.20.11 1567 | tar -xvf -</span><br></pre></td></tr></tbody></table></figure>

<p>同上，这里客户端接受完目录之后不会自动退出</p>
<p>客户端 -&gt; 服务器：</p>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment"># S</span></span><br><span class="line">nc -l 1567 | tar -xvf -</span><br><span class="line"><span class="comment"># C</span></span><br><span class="line">tar -cvf - test-nc | nc 10.10.20.11 1567</span><br></pre></td></tr></tbody></table></figure>

<h4 id="传送加密文件"><a href="#传送加密文件" class="headerlink" title="传送加密文件"></a>传送加密文件</h4><p>客户端 -&gt; 服务器</p>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment"># S</span></span><br><span class="line">nc -l 1567 | mcrypt -m ecb -F -k password -q -d &gt; some.file</span><br><span class="line"><span class="comment"># C</span></span><br><span class="line">mcrypt -m ecb -F -k password -q &lt; some.file  | nc -N 10.10.20.11 1567</span><br></pre></td></tr></tbody></table></figure>

<p>mcrpyt 参数</p>
<ul>
<li>-m 模式</li>
<li> -F 输出到 stdout</li>
<li>-k 密码</li>
<li> -q 安静模式，忽略警告信息</li>
</ul>
<h3 id="克隆硬盘"><a href="#克隆硬盘" class="headerlink" title="克隆硬盘"></a>克隆硬盘</h3><p>服务器 -&gt; 客户端</p>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment"># S:</span></span><br><span class="line">dd <span class="keyword">if</span>=/dev/sda | nc -l 1567</span><br><span class="line"><span class="comment"># C</span></span><br><span class="line">nc 127.0.0.1 1567 | dd of=dev/sda`</span><br></pre></td></tr></tbody></table></figure>

<p>dd 会读取硬盘的原始数据，会随着分区表拷贝所有的信息</p>
<h3 id="代理服务"><a href="#代理服务" class="headerlink" title="代理服务"></a>代理服务</h3><h4 id="代理ssh流量"><a href="#代理ssh流量" class="headerlink" title="代理ssh流量"></a>代理 ssh 流量</h4><p>客户端 操作 服务器：</p>
<p>打开一个 shell，如果我们没有权限安装 ssh 也可以用 netcat 创建远程 shell</p>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment"># S</span></span><br><span class="line">mkfifo /tmp/tmp_fifo</span><br><span class="line">cat /tmp/tmp_fifo | /bin/bash -i 2&gt;&amp;1 | nc -l 1567 &gt; /tmp/tmp_fifo</span><br><span class="line"><span class="comment"># C</span></span><br><span class="line">nc 127.0.0.1 1567</span><br></pre></td></tr></tbody></table></figure>

<p>会创建一个连接，并且在连接成功时知性 /bin/bash</p>
<ol>
<li>服务器从网络接受输入写入 fifo 文件中</li>
<li> cat 命令读取 fifo 文件内容兵发送至 bash</li>
<li>bash 的输出重定向至 nc</li>
<li>nc 将数据发送至 client</li>
<li> 其中：fifo 使读取等待，让这个过程可以一直执行，</li>
</ol>
<p>利用这个 nc + fifo 还可以实现创建 HTTP 代理服务器等功能。</p>
<p>服务器 操作 客户端：</p>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment"># S</span></span><br><span class="line">nc -l 1567</span><br><span class="line"><span class="comment"># C</span></span><br><span class="line">mkfifo /tmp/tmp_fifo</span><br><span class="line">cat /tmp/tmp_fifo | /bin/bash -i 2&gt;&amp;1 |nc 10.10.20.11 1567 &gt; /tmp/tmp_fifo</span><br></pre></td></tr></tbody></table></figure>

<p>原理同上；用于 client 位于内网或者防火墙背后，client 连接上 server 之后，可以使用 server 来反向操作 client 的 shell</p>
]]></content>
      <categories>
        <category>Linux</category>
        <category>Command</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>网络是如何连接的：中继、集线器、交换机与网桥</title>
    <url>/posts/c338/</url>
    <content><![CDATA[<p>之前一直对二层网络连接的知识体系模模糊糊，最近有空就总结了下。</p>
<span id="more"></span>

<p>这篇主要区分了一下常见的网络设备：</p>
<pre class="mermaid">graph TB
    a(中继)
    b(集线器)
    c(网桥)
    d(交换机)
    e(网关)
    f(路由器)
%%</pre>

<p>上述设备工作的 OSI 网络层次分别是：</p>
<pre class="mermaid">graph TB
    L5(应用层/表示层/会话层)
    L4(传输层)
    L3(网络层)
    L2(数据链路层)
    L1(物理层)
    H1([网卡,中继,集线器])
    H2([网桥,交换机])
    H3([路由器,网关])
subgraph OSI网络模型
    L5 --&gt; L4 --&gt; L3 --&gt; L2 --&gt; L1
end
    H1 -.-&gt; L1
    H2 -.-&gt; L2
    H3 -.-&gt; L3

classDef comment fill:#fff,stroke:gray,stroke-dasharray: 5 5
class H1,H2,H3 comment
%%</pre>

<h3 id="中继器-Repeater"><a href="#中继器-Repeater" class="headerlink" title="中继器 Repeater"></a>中继器 Repeater</h3><p>为什么要有中继器？</p>
<p>当只有两台设备需要互相通信时，我们可以仅使用网线将设备连接起来。当两台需要通信的设备物理间隔比较远时，由于信号的衰减，我们就需要中继器来放大信号，使得信号传的更远。</p>
<ul>
<li>理论上只有一进一出两个端口，将进入端口的信号转发至另一个端口。</li>
<li>单纯的信号放大装置，用来扩大信号的传输距离。</li>
<li>典型的例子是：家里 WIFI 信号不够好时，可以通过增加中继器或把额外的路由器设置为中继模式来扩展 WIFI 覆盖范围。</li>
</ul>
<p>下面两中拓扑结构的最终效果是等价的：</p>
<pre class="mermaid">flowchart LR

c1(A fas:fa-desktop) o--o h1(fas:fa-bolt 中继器) o--o c2(B fas:fa-desktop)

c3(A fas:fa-desktop) o---o c4(B fas:fa-desktop)
%%</pre>

<p>中继器没有做到的事情：</p>
<p>中继器解决了远距离传播信号的问题。但是现实中我们不会仅仅只需两台设备互相通信，而是多台设备都能互相通信，这种情况下我们就需要更高级的设备了。</p>
<h3 id="集线器-Hub"><a href="#集线器-Hub" class="headerlink" title="集线器 Hub"></a>集线器 Hub</h3><p>中继器解决了两台设备远距离通信的问题，但是当多台设备需要互相通信时，需要在任意两台设备之间连接一条网线，网络拓扑是这样的：</p>
<pre class="mermaid">flowchart LR
    c1(A fas:fa-desktop)
    c2(B fas:fa-desktop)
    c3(C fas:fa-desktop)

    c1 --- c2
    c1 --- c3
    c2 --- c3
%%</pre>

<p>网络中每增加一台设备，主机 A 就增加一条网线，这显然是现实的。为了解决这个问题，集线器被发明了。</p>
<p>集线器用最简单的方式解决了多台设备互相通信的问题。具体的做法是：集线器有多个端口，可以连接多个设备（如下图）。当一台设备发送了数据帧，集线器会将这个数据帧转发至其他左右的端口。</p>
<p>下图是一个集线器构成的网络拓扑，A 发送了一个数据帧给 C，这个数据先被集线器收到：</p>
<pre class="mermaid">flowchart LR
    c1(A fas:fa-desktop)
    h1(fas:fa-boxes 集线器)
    c2(B fas:fa-desktop)
    c3(C fas:fa-desktop)
    c4(D fas:fa-desktop)
    c1 --&gt; | 给 C 的消息 | h1
    h1 --- c2
    h1 --- c3
    h1 --- c4
%%</pre>

<p>集线器将消息发送至除 A 外的每一台设备：</p>
<pre class="mermaid">flowchart LR
    c1(A fas:fa-desktop)
    h1(fas:fa-boxes 集线器)
    c2(B fas:fa-desktop)
    c3(C fas:fa-desktop)
    c4(D fas:fa-desktop)
    c1 --- h1
    h1 --&gt; | 给 C 的消息 | c2
    h1 --&gt; | 给 C 的消息 | c3
    h1 --&gt; | 给 C 的消息 | c4
%%</pre>

<p>之后 B、D 会将不需要的消息丢弃掉，C 收到的消息会被正常处理。这个过程中 B、D 两个设备的带宽就被浪费掉了。<br>由于使用集线器的通讯方式是广播通信（数据会发给每一个连接到集线器的设备），因此还会有一定的安全隐患。</p>
<p>总结集线器：</p>
<ul>
<li>有多个端口，可以连接多台终端，让彼此存在互相通信的可能。</li>
<li>将一个端口的信号转发至其他所有的端口。</li>
<li>可以看成一个多端口的中继器。</li>
<li>缺陷<ul>
<li>网络规模较小。</li>
<li>集线器的最大问题是多设备共享带宽。因为集线器同一个时刻仅能够执行一个收 / 发任务，所以网络拓扑中的设备越多，每台设备分到的带宽就越小，限制了网络的扩展。</li>
<li>数据帧以广播的方式发送（会发送到每台设备上），有信息泄漏的风险。</li>
</ul>
</li>
</ul>
<h3 id="网桥-Bridge"><a href="#网桥-Bridge" class="headerlink" title="网桥 Bridge"></a>网桥 Bridge</h3><p>为了解决集线器构成的网络拓扑中规模较小的问题，网桥被发明出来了。</p>
<ul>
<li>至少有两端口。</li>
<li>集线器会对每个端口维护一个 MAC 地址列表。当某个端口连接的是主机时，记录的 MAC 地址就是该主机的 MAC 地址；当连接的是集线器时，记录的 MAC 地址就是集线器上连接的所有主机的 MAC 地址。</li>
<li>当网桥收到主机 / 集线器发来的数据帧时，会对比数据帧中的<strong>目的 MAC 地址</strong>，如果该地址不再对应端口的 MAC 地址表中，才会向另一个端口转发该数据帧。</li>
<li>相比于集线器连接的网络，可以减少无效的转发，提高效率。</li>
</ul>
<p>其网络拓扑如下 (以两个端口的网桥为例)：</p>
<pre class="mermaid">flowchart LR
    c1(A fas:fa-desktop)
    c2(B fas:fa-desktop)
    c3(C fas:fa-desktop)
    c4(D fas:fa-desktop)
    c5(E fas:fa-desktop)
    c6(F fas:fa-desktop)
    c7(G fas:fa-desktop)
    c8(H fas:fa-desktop)
    h1(fas:fa-boxes 集线器 A)
    h2(fas:fa-boxes 集线器 B)
    b1(fas:fa-network-wired 网桥)
    c1 --- h1
    c2 --- h1
    c3 --- h1
    c4 --- h1
    h1 --- b1 --- h2
    h2 --- c5
    h2 --- c6
    h2 --- c7
    h2 --- c8

    com2(端口2:\nmacE,\nmacF,\nmacG,\nmacH,) 
    com1(端口1:\nmacA,\nmacB,\nmacC,\nmacD,)
    com1 -.- b1
    b1 -.- com2

    classDef comment fill:#fff,stroke:gray,stroke-dasharray: 5 5
    class com1,com2 comment
%%</pre>

<p>如图上：</p>
<ul>
<li>当 A 向 F 发送数据帧 <code>AtoF</code>。<ul>
<li><code>AtoF</code> 会现被 A 发送 集线器 A。</li>
<li>集线器 A 将 <code>AtoF</code> 发送到网桥（此时集线器 A 连接的是网桥的端口 1）。</li>
<li>网桥查看 F 是否在端口 1 对应的 MAC 表中存在：<ul>
<li>存在：网桥会丢弃该数据帧；</li>
<li>不存在；接下来查找其他端口的 MAC 表，看 F 是否在某个表中存在：<ul>
<li>存在：从这个端口中转发该数据帧。</li>
<li>不存在：则将 <code>AtoF</code> 从端口 1 以外的所有端口发送出去。（<strong>泛洪</strong>）</li>
</ul>
</li>
</ul>
</li>
<li>集线器 B 会将 <code>AtoF</code> 转发到 F 上，通信完成。</li>
</ul>
</li>
<li>另一种情况，当 B 向 D 发送数据帧：<code>BtoD</code>。<ul>
<li><code>BtoD</code> 会现被 B 发送 集线器 A。</li>
<li>集线器 A 将 <code>BtoD</code> 发送到网桥。</li>
<li>网桥会对查看端口 1 对应的 MAC 地址表，D 的地址在 MAC 地址表中，则网桥不做转发。</li>
</ul>
</li>
</ul>
<h4 id="网桥的mac地址表是怎么建立起来的？"><a href="#网桥的mac地址表是怎么建立起来的？" class="headerlink" title="网桥的mac地址表是怎么建立起来的？"></a>网桥的 mac 地址表是怎么建立起来的？</h4><p>还是以上面的过程为例：</p>
<ul>
<li>当网桥刚刚开机，两个端口对应的 mac 地址表都为空。</li>
<li>假设网桥从端口 1 中收到一个 AtoE 发出来的数据帧，此时网桥会执行两个动作：<ul>
<li>查看 E 的 MAC 地址时都在端口 1 的 MAC 表中；不在，于是向端口 2 转发该数据帧</li>
<li>取得数据帧中的<strong>源 MAC 地址（即 A）</strong>，将其加入到端口 1 的地址表中。</li>
</ul>
</li>
<li>假设此时网桥又从端口 1 收到一个 BtoA 的数据帧：<ul>
<li>比对目的地址 A 是否在对应的地址表中；在，于是丢弃该数据帧，<strong>不做转发</strong></li>
<li>将源地址 B 加入端口 1 的 MAC 地址表中。</li>
</ul>
</li>
<li>下次再有<strong>目的地址</strong>是 A 或者 B 的数据帧从<strong>端口 1</strong> 到达时，网桥就知道<strong>不应该</strong>转发该数据帧了。</li>
</ul>
<h4 id="网桥建立的网络拓扑存在的缺陷"><a href="#网桥建立的网络拓扑存在的缺陷" class="headerlink" title="网桥建立的网络拓扑存在的缺陷"></a>网桥建立的网络拓扑存在的缺陷</h4><p>相对于集线器，网桥极大的减少了广播数据，使得数据帧被限制在较小的范围内。同时提高了带宽的利用率。但是网桥并不是完美的。</p>
<ul>
<li>当 MAC 地址表为空时，网桥会转发收到的数据帧，使得该数据帧在网桥连接的网络上扩散，最终每台设备机器都会收到这个数据帧。</li>
<li>当网桥判断出目的 MAC 地址不在 MAC 表中时，会将数据帧发往桥的另一端。但是网桥并不知道另一端是否存在这个地址（事实上绝大部分时间都不在）。</li>
<li>在一些特殊的场景下，如广播 / 多播需求，网桥会将数据帧扩散到整个网络上，造成广播风暴。</li>
</ul>
<h3 id="交换机-Switch"><a href="#交换机-Switch" class="headerlink" title="交换机 Switch"></a>交换机 Switch</h3><ul>
<li>交换机是一种性能增强版的网桥。</li>
<li>交换机通常具有较多的端口，每两个端口都可以作为一组网桥来使用。交换机可以看做是一堆网桥的合集。</li>
<li>同网桥一样交换机也维护了端口到 MAC 地址的映射表</li>
</ul>
<p>两者在逻辑模型上并没有更多的区别。</p>
<h4 id="网桥、交换机与生成树协议"><a href="#网桥、交换机与生成树协议" class="headerlink" title="网桥、交换机与生成树协议"></a>网桥、交换机与生成树协议</h4><p>拓展一下上面的例子，把两个端口的网桥换成多端口网桥（交换机），会出现这样一种网络拓扑：</p>
<pre class="mermaid">flowchart LR
    c1(A fas:fa-desktop)
    c2(B fas:fa-desktop)
    b1(fas:fa-network-wired 网桥1)
    b2(fas:fa-network-wired 网桥2)
    b3(fas:fa-network-wired 网桥3)
    c1 --&gt; | AtoB| b1
    b1 --- b2
    b1 --- b3
    b2 --- b3
    b3 --- c2
%%</pre>

<p>图中是一个三个网桥形成的环状结构，其中主机 A 发出一个数据帧 <code>AtoB</code>，根据上文的模型，B 的 MAC 地址不在网桥 1 左侧端口的 MAC 表中，网桥 1 会将 <code>AtoB</code> 转发至另外的两个端口：</p>
<pre class="mermaid">flowchart LR
    c1(A fas:fa-desktop)
    c2(B fas:fa-desktop)
    b1(fas:fa-network-wired 网桥1)
    b2(fas:fa-network-wired 网桥2)
    b3(fas:fa-network-wired 网桥3)
    c1 --- b1
    b1 --&gt; | AtoB| b2
    b1 --&gt; | AtoB| b3
    b2 --- b3
    b3 --- c2
%%</pre>

<p>再下一步，网桥 2 将左侧端口收到的数据帧向右侧端口转发，同时网桥 3 将收到的数据帧向其余两个端口转发：</p>
<pre class="mermaid">flowchart LR
    c1(A fas:fa-desktop)
    c2(B fas:fa-desktop)
    b1(fas:fa-network-wired 网桥1)
    b2(fas:fa-network-wired 网桥2)
    b3(fas:fa-network-wired 网桥3)
    c1 --- b1
    b1 --- b2
    b1 --- b3
    b2 -.-&gt; | AtoB| b3
    b3 --&gt; | AtoB| c2
    b3 -.-&gt; | AtoB| b2
%%</pre>

<p>可以看出网桥 2 和网桥 3 会互相转发 AtoB 这个数据帧。如果不加干预的话，并且这个数据帧会一直在这个三个网桥形成的环中传递。</p>
<p>为了解决这个问题，网桥都具备一个 “破环功能”，该功能实现的原理是：最小生成树协议。这个协议详情本文不做说明，后面的 Blog 再写这个。</p>
]]></content>
      <categories>
        <category>Network</category>
      </categories>
      <tags>
        <tag>网络基础</tag>
      </tags>
  </entry>
  <entry>
    <title>Golang 项目目录风格</title>
    <url>/posts/96df/</url>
    <content><![CDATA[<p>总结的 Go Project 目录推荐风格。</p>
<span id="more"></span>

<p>出自项目 <a href="https://github.com/golang-standards/project-layout">golang-standards/project-layout</a>，去掉一些冗余信息之后成文。</p>
<p>写在前面：</p>
<ul>
<li>这里描述的风格是一些常见的项目的代码组织布局，并非官方标准，事实上官方也没有规定标准。</li>
<li>其目的是通过共识减少协作中的沟通成本，以提高开发 / 传播效率。</li>
<li>仅作为推荐，应该自由的取舍。</li>
<li>Go 1.14 以上请使用 <code>Go Modules</code> 管理项目。</li>
</ul>
<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>常见的目录结构：</p>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">├── LICENSE.md</span><br><span class="line">├── Makefile</span><br><span class="line">├── api</span><br><span class="line">│&nbsp;&nbsp; ├── swagger</span><br><span class="line">│&nbsp;&nbsp; └── protobuf</span><br><span class="line">├── assets</span><br><span class="line">├── build</span><br><span class="line">│&nbsp;&nbsp; ├── ci</span><br><span class="line">│&nbsp;&nbsp; └── package</span><br><span class="line">├── cmd</span><br><span class="line">│&nbsp;&nbsp; ├── myapp1</span><br><span class="line">│&nbsp;&nbsp; └── myapp2</span><br><span class="line">├── configs</span><br><span class="line">├── deployments</span><br><span class="line">├── docs</span><br><span class="line">├── examples</span><br><span class="line">├── githooks</span><br><span class="line">├── go.mod</span><br><span class="line">├── init</span><br><span class="line">├── internal</span><br><span class="line">│&nbsp;&nbsp; ├── app</span><br><span class="line">│&nbsp;&nbsp; │   ├── myapp1</span><br><span class="line">│&nbsp;&nbsp; │&nbsp;&nbsp; └── myapp2</span><br><span class="line">│&nbsp;&nbsp; └── pkg</span><br><span class="line">│&nbsp;&nbsp;     ├── apppkg1</span><br><span class="line">│&nbsp;&nbsp;     └── apppkg2</span><br><span class="line">├── pkg</span><br><span class="line">│&nbsp;&nbsp; ├── mypkg1</span><br><span class="line">│&nbsp;&nbsp; └── mypkg2</span><br><span class="line">├── scripts</span><br><span class="line">├── <span class="built_in">test</span></span><br><span class="line">├── third_party</span><br><span class="line">├── tools</span><br><span class="line">├── web</span><br><span class="line">│&nbsp;&nbsp; ├── app</span><br><span class="line">│   │   └── api</span><br><span class="line">│&nbsp;&nbsp; ├── static</span><br><span class="line">│&nbsp;&nbsp; └── template</span><br><span class="line">└── website</span><br></pre></td></tr></tbody></table></figure>

<hr>
<h2 id="Go-核心代码相关目录"><a href="#Go-核心代码相关目录" class="headerlink" title="Go 核心代码相关目录"></a>Go 核心代码相关目录</h2><h3 id="cmd"><a href="#cmd" class="headerlink" title="cmd"></a><code>cmd</code></h3><p>项目编译出的可执行文件的目录，一般来说 cmd 下每一个 dir 都应该对应一个可执行文件。</p>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">├── cmd</span><br><span class="line">│&nbsp;&nbsp; ├── myapp1</span><br><span class="line">│&nbsp;&nbsp; └── myapp2</span><br></pre></td></tr></tbody></table></figure>

<p>注意：</p>
<ul>
<li>cmd 中最好只防止程序的入口代码，保持 cmd 的代码简洁，通过调用 pkg 和 internal 目录下的代码来建立整个程序逻辑。</li>
<li>一个子目录对应一个可执行文件。</li>
<li>子目录名与可执行文件的名称相匹配 (例如，<code>/cmd/myapp1</code>)。</li>
<li>在文件中只保留一个 main 函数是一种推荐的做法。</li>
</ul>
<h3 id="internal"><a href="#internal" class="headerlink" title="internal"></a><code>internal</code></h3><p>用来存放非共享的代码。go 的引用机制决定了 intelnal 目录中的代码只能够被 intelnal 下的内部代码引用。</p>
<p>Go 1.4 关于 <a href="https://golang.org/doc/go1.4#internalpackages"><code>internal package 的说明</code></a> 。</p>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">├── internal</span><br><span class="line">│&nbsp;&nbsp; ├── app</span><br><span class="line">│&nbsp;&nbsp; │   ├── myapp1</span><br><span class="line">│&nbsp;&nbsp; │&nbsp;&nbsp; └── myapp2</span><br><span class="line">│&nbsp;&nbsp; └── pkg</span><br><span class="line">│&nbsp;&nbsp;     ├── apppkg1</span><br><span class="line">│&nbsp;&nbsp;     └── apppkg2</span><br></pre></td></tr></tbody></table></figure>

<p>注意：</p>
<ul>
<li>用来存放非共享的代码。</li>
<li>intelnal 目录并不只局限于根目录下的 internal 目录，还可以是项目目录树的任何 internal 目录。</li>
<li>internal 下依然可以有语意化的目录组织形式，上例中 app 存放各 app 的代码，pkg 存放 app 之间的共享代码，但是这些共享代码不对项目外开放。</li>
</ul>
<h3 id="pkg"><a href="#pkg" class="headerlink" title="pkg"></a><code>pkg</code></h3><p>用来存放可以对外部共享的库代码。</p>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">├── pkg</span><br><span class="line">│&nbsp;&nbsp; ├── mypkg1</span><br><span class="line">│&nbsp;&nbsp; └── mypkg2</span><br></pre></td></tr></tbody></table></figure>

<p>注意：</p>
<ul>
<li>供外部使用的代码最好具有完善的测试和文档。</li>
<li>参考 Travis Jeffery 的 blog <a href="https://travisjeffery.com/b/2019/11/i-ll-take-pkg-over-internal/"><code>I'll take pkg over internal</code></a> 更深入的理解 pkg /internal 的使用方法。</li>
</ul>
<h3 id="vendor"><a href="#vendor" class="headerlink" title="vendor"></a><code>vendor</code></h3><p>淘汰，不表。</p>
<h2 id="服务应用程序目录"><a href="#服务应用程序目录" class="headerlink" title="服务应用程序目录"></a>服务应用程序目录</h2><h3 id="api"><a href="#api" class="headerlink" title="api"></a><code>api</code></h3><p>用来放置 API 的描述文件，如：OpenAPI/Swagger 文件，JSON Schema，protobuf 文件。</p>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">├── api</span><br><span class="line">│&nbsp;&nbsp; ├── swagger</span><br><span class="line">│&nbsp;&nbsp; └── protobuf</span><br></pre></td></tr></tbody></table></figure>

<p>有关示例，请参见 <a href="https://github.com/golang-standards/project-layout/tree/master/api"><code>/api</code></a> 目录。</p>
<h2 id="Web-应用程序目录"><a href="#Web-应用程序目录" class="headerlink" title="Web 应用程序目录"></a>Web 应用程序目录</h2><h3 id="web"><a href="#web" class="headerlink" title="/web"></a><code>/web</code></h3><p>特定于 Web 应用程序的组件：静态 Web 资产、服务器端模板和 SPAs。</p>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">├── web</span><br><span class="line">│&nbsp;&nbsp; ├── app</span><br><span class="line">│   │   └── api</span><br><span class="line">│&nbsp;&nbsp; ├── static</span><br><span class="line">│&nbsp;&nbsp; └── template</span><br></pre></td></tr></tbody></table></figure>

<h2 id="通用应用目录"><a href="#通用应用目录" class="headerlink" title="通用应用目录"></a>通用应用目录</h2><h3 id="configs"><a href="#configs" class="headerlink" title="/configs"></a><code>/configs</code></h3><p>配置文件模板或默认配置。</p>
<p>将你的 <code>confd</code> 或 <code>consul-template</code> 模板文件放在这里。</p>
<h3 id="init"><a href="#init" class="headerlink" title="/init"></a><code>/init</code></h3><p>系统初始化工具，如：systemd、process manager、supervisor、等配置</p>
<h3 id="scripts"><a href="#scripts" class="headerlink" title="/scripts"></a><code>/scripts</code></h3><p>构建、安装、分析等的脚本，这些脚本并不是被直接执行，而是应该在 Makefile 中被触发。</p>
<p>示例见  <a href="https://github.com/golang-standards/project-layout/blob/master/scripts/README.md"><code>scripts</code></a> 目录。</p>
<h3 id="build"><a href="#build" class="headerlink" title="/build"></a><code>/build</code></h3><p>构建和 CI 等。</p>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">├── build</span><br><span class="line">│&nbsp;&nbsp; ├── ci</span><br><span class="line">│&nbsp;&nbsp; └── package</span><br></pre></td></tr></tbody></table></figure>

<p>注意：</p>
<ul>
<li>package 目录中放置包配置脚本，如：docker，AMI，deb，pkg 之类。</li>
<li>ci 目录放置 ci 工具需要的配置和脚本。</li>
<li>像是 travisCI 对位置要求较高的工具，可以尝试使用软连接将脚本链接到指定的位置。</li>
</ul>
<h3 id="deployments"><a href="#deployments" class="headerlink" title="/deployments"></a><code>/deployments</code></h3><p>放置部署配置和脚本，如：docker-compose，kubernetes/helm，mesos，helm、mesos、terraform、bosh 等<br>在 kubernetes 的环境中，可能被命名为 deploy。</p>
<h3 id="test"><a href="#test" class="headerlink" title="/test"></a><code>/test</code></h3><p>放置外部测试和测试数据。</p>
<p>注意：</p>
<ul>
<li>go 会忽略 <code>/test/data</code> 或 <code>/test/testdata</code> 目录，可以用他们放置测试数据。</li>
<li>go 还会忽略 “.” 或 “_” 开头的文件或目录。</li>
</ul>
<p>示例见  <a href="https://github.com/golang-standards/project-layout/blob/master/test/README.md"><code>/test</code></a> 目录。</p>
<h2 id="其他目录"><a href="#其他目录" class="headerlink" title="其他目录"></a>其他目录</h2><h3 id="docs"><a href="#docs" class="headerlink" title="/docs"></a><code>/docs</code></h3><p>设计和用户文档 (不包含 godoc 生成的文档)。</p>
<p>有关示例，请参阅 <a href="https://github.com/golang-standards/project-layout/blob/master/docs/README.md"><code>/docs</code></a> 目录。</p>
<h3 id="tools"><a href="#tools" class="headerlink" title="/tools"></a><code>/tools</code></h3><p>这个项目的辅助工具。工具可以从 <code>/pkg</code> 和 <code>/internal</code> 目录导入代码。</p>
<p>示例见 <a href="https://github.com/golang-standards/project-layout/blob/master/tools/README.md"><code>/tools</code></a> 目录。</p>
<h3 id="examples"><a href="#examples" class="headerlink" title="/examples"></a><code>/examples</code></h3><p>你的应用程序和 / 或公共库的示例。</p>
<p>示例见 <a href="https://github.com/golang-standards/project-layout/blob/master/examples/README.md"><code>/examples</code></a> 目录。</p>
<h3 id="third-party"><a href="#third-party" class="headerlink" title="/third_party"></a><code>/third_party</code></h3><p>外部辅助工具，分叉代码和其他第三方工具 (例如 Swagger UI)。</p>
<h3 id="githooks"><a href="#githooks" class="headerlink" title="/githooks"></a><code>/githooks</code></h3><p>Git hooks。</p>
<h3 id="assets"><a href="#assets" class="headerlink" title="/assets"></a><code>/assets</code></h3><p>与存储库一起使用的其他资源 (图像、logo 等)。</p>
<h3 id="website"><a href="#website" class="headerlink" title="/website"></a><code>/website</code></h3><p>如果你不使用 Github 页面，则在这里放置项目的网站数据。</p>
<p>有关示例，请参见 <a href="website/README.md"><code>/website</code></a> 目录。</p>
<h2 id="不推荐的目录"><a href="#不推荐的目录" class="headerlink" title="不推荐的目录"></a>不推荐的目录</h2><h3 id="src"><a href="#src" class="headerlink" title="/src"></a><code>/src</code></h3><p>src 是很有 java 背景的文件夹，如果可以，尽量不要采用这种风格。</p>
<hr>
<h2 id="关于代码风格的一些参考"><a href="#关于代码风格的一些参考" class="headerlink" title="关于代码风格的一些参考"></a>关于代码风格的一些参考</h2><p>如果需要命名、格式和样式方面的帮助，运行 <a href="https://golang.org/cmd/gofmt/"><code>gofmt</code></a> 和 <a href="https://github.com/golang/lint"><code>golint</code></a> 。</p>
<p>最好多看看 Go 代码风格的建议:</p>
<ul>
<li><a href="https://talks.golang.org/2014/names.slide">talks.golang.org/2014/names</a></li>
<li><a href="https://golang.org/doc/effective_go.html#names">golang.org/doc/effective_go.html#names</a></li>
<li><a href="https://blog.golang.org/package-names">blog.golang.org/package-names</a></li>
<li><a href="https://github.com/golang/go/wiki/CodeReviewComments">github.com/golang/go/wiki/CodeReviewComments</a></li>
<li><a href="https://rakyll.org/style-packages">Style guideline for Go packages</a> (rakyll/JBD)</li>
</ul>
<p>参见 <a href="https://medium.com/golang-learn/go-project-layout-e5213cdcfaa2"><code>Go Project Layout</code></a> 了解更多的信息。</p>
<p>更多关于包的命名和组织以及其他代码结构的建议:</p>
<ul>
<li><a href="https://www.youtube.com/watch?v=PTE4VJIdHPg">GopherCon EU 2018: Peter Bourgon - Best Practices for Industrial Programming</a></li>
<li><a href="https://www.youtube.com/watch?v=MzTcsI6tn-0">GopherCon Russia 2018: Ashley McNamara + Brian Ketelsen - Go best practices.</a></li>
<li><a href="https://www.youtube.com/watch?v=ltqV6pDKZD8">GopherCon 2017: Edward Muller - Go Anti-Patterns</a></li>
<li><a href="https://www.youtube.com/watch?v=oL6JBUk6tj0">GopherCon 2018: Kat Zien - How Do You Structure Your Go Apps</a></li>
</ul>
]]></content>
      <categories>
        <category>Golang</category>
      </categories>
      <tags>
        <tag>Golang</tag>
      </tags>
  </entry>
  <entry>
    <title>Shell (Bash) 编程（篇一）：语法基础</title>
    <url>/posts/c8ef/</url>
    <content><![CDATA[<p>之前零零碎碎学了几遍 shell（主要是 bash）编程的语法，用的不多很容易忘，归纳一下常用语法备查。</p>
<span id="more"></span>

<p>详细的教程与示例，请参考官方的文档或其他优秀的教程：</p>
<ol>
<li><a href="https://www.gnu.org/savannah-checkouts/gnu/bash/manual/bash.html">www.gnu.org GNU 的 Bash 手册（英文）</a></li>
<li><a href="https://wangdoc.com/bash/index.html">阮一峰：Bash 脚本教程</a></li>
<li><a href="https://www.runoob.com/linux/linux-shell.html">runoob.com 菜鸟教程：Shell</a></li>
</ol>
<h3 id="内容规划"><a href="#内容规划" class="headerlink" title="内容规划"></a>内容规划</h3><ul>
<li>变量与语句：声明和使用，特殊变量</li>
<li>类型：字符串，数组</li>
<li>运算与运算符：算数运算，关系运算，逻辑运算</li>
<li>流程控制：循环，分支，函数</li>
</ul>
<h3 id="变量与语句"><a href="#变量与语句" class="headerlink" title="变量与语句"></a>变量与语句</h3><h4 id="声明和使用"><a href="#声明和使用" class="headerlink" title="声明和使用"></a>声明和使用</h4><p>基础用法</p>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment"># 声明</span></span><br><span class="line">myname=<span class="string">"zhaopeng"</span></span><br><span class="line">arr=(11 22 33)      <span class="comment"># 声明一个数组</span></span><br><span class="line"><span class="built_in">readonly</span> myname     <span class="comment"># 只读变量</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用</span></span><br><span class="line">arr[3]=44           <span class="comment"># 给第四个元素赋值</span></span><br><span class="line"><span class="built_in">echo</span> arr[@]         <span class="comment"># 打印数组所有的元素</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">${myname}</span>      <span class="comment"># 打印</span></span><br><span class="line"><span class="built_in">unset</span> myname        <span class="comment"># 删除变量</span></span><br></pre></td></tr></tbody></table></figure>

<p>变量的条件引用</p>
<p>变量替换时根据变量的具体的状态 (值) 来改变条件引用的值</p>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment"># 条件A:name未定义; 条件B:name为空</span></span><br><span class="line"><span class="comment">#                           成立条件:    执行结果:</span></span><br><span class="line"><span class="variable">${name}</span>                     <span class="comment"># -         返回 name 的值</span></span><br><span class="line"><span class="variable">${name-"default"}</span>           <span class="comment"># A         返回 default</span></span><br><span class="line"><span class="variable">${name:-"default"}</span>          <span class="comment"># A or B    返回 default</span></span><br><span class="line"><span class="variable">${name="default"}</span>           <span class="comment"># A         返回 default, 并赋值给name</span></span><br><span class="line"><span class="variable">${name:="default"}</span>          <span class="comment"># A or B    返回 default, 并赋值给name</span></span><br><span class="line"><span class="variable">${name?"default"}</span>           <span class="comment"># A         返回 default, 并终止脚本</span></span><br><span class="line"><span class="variable">${name:?"default"}</span>          <span class="comment"># A or B    返回 default, 并终止脚本</span></span><br><span class="line"><span class="variable">${name+"default"}</span>           <span class="comment"># !A        返回 default</span></span><br><span class="line"><span class="variable">${name:+"default"}</span>          <span class="comment"># !A and !B 返回 default</span></span><br></pre></td></tr></tbody></table></figure>

<h4 id="特殊变量"><a href="#特殊变量" class="headerlink" title="特殊变量"></a>特殊变量</h4><p>一些以 <code>$</code> 开头的特殊变量，在 shell 中有特殊的含义</p>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">$$ <span class="comment"># 当前shell进程的ID</span></span><br><span class="line"><span class="variable">$0</span> <span class="comment"># 当前脚本的文件名</span></span><br><span class="line"><span class="variable">$1</span> <span class="comment"># 传递给脚本(或函数)的第一个参数</span></span><br><span class="line"><span class="variable">$#</span> <span class="comment"># 传递给脚本或函数的参数个数</span></span><br><span class="line">$* <span class="comment"># 函数的全部参数，参数之间使用变量$IFS值的第一个字符分隔，默认空格，可自定义</span></span><br><span class="line"><span class="variable">$@</span> <span class="comment"># 传递给脚本或函数的所有参数, 空格分隔</span></span><br><span class="line">$? <span class="comment"># 上个命令的退出状态，或函数的返回值</span></span><br></pre></td></tr></tbody></table></figure>

<p>举例：</p>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line"><span class="built_in">print</span> each param from <span class="string">"$*"</span></span><br><span class="line">// 111 222 333</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span> each param from <span class="string">"<span class="variable">$@</span>"</span></span><br><span class="line">// 111</span><br><span class="line">// 222</span><br><span class="line">// 333</span><br></pre></td></tr></tbody></table></figure>

<h3 id="类型"><a href="#类型" class="headerlink" title="类型"></a>类型</h3><h4 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h4><p>截取字符串</p>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line"><span class="variable">${name:start}</span>       <span class="comment"># 从start取到末尾</span></span><br><span class="line"><span class="variable">${name:start:len}</span>   <span class="comment"># 从start开始取len个字符</span></span><br><span class="line"><span class="variable">${name#schema}</span>      <span class="comment"># 删除左侧匹配到的schema            eg：`${address#*四川省}`</span></span><br><span class="line"><span class="variable">${name##schema}</span>     <span class="comment"># 删除左侧匹配到的schema，贪婪模式   eg：`${address##*四川省}`</span></span><br><span class="line"><span class="variable">${name%schema}</span>      <span class="comment"># 删除右侧匹配到的schema            eg：`${address%*四川省}`</span></span><br><span class="line"><span class="variable">${name%%schema}</span>     <span class="comment"># 删除右侧匹配到的schema，贪婪模式   eg：`${address%%*四川省}`</span></span><br><span class="line"><span class="variable">$name</span>[start,end]    <span class="comment"># zsh only，区start到end的字符</span></span><br></pre></td></tr></tbody></table></figure>

<p>其中的 schema 可以是正则表达式，截取字符串的几个例子：</p>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="variable">${file%/*}</span>       <span class="comment"># 取目录</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">${file##*/}</span>      <span class="comment"># 取文件名</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">${file##*.}</span>      <span class="comment"># 取扩展名</span></span><br></pre></td></tr></tbody></table></figure>

<p>替换字符串</p>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line"><span class="variable">${name/from/to}</span>     <span class="comment"># 将from替换为to，限第一个</span></span><br><span class="line"><span class="variable">${name/from}</span>        <span class="comment"># 将from删除</span></span><br><span class="line"><span class="variable">${name//from/to}</span>    <span class="comment"># 将from替换为to，所有</span></span><br><span class="line"><span class="variable">${name//from}</span>       <span class="comment"># 将from删除</span></span><br><span class="line"><span class="variable">${name/#from/to}</span>    <span class="comment"># #：从首字符开始匹配</span></span><br><span class="line"><span class="variable">${name/%from/to}</span>    <span class="comment"># %：从尾字符开始匹配</span></span><br></pre></td></tr></tbody></table></figure>

<p>其中 from 可以是正则表达式，eg:</p>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line"><span class="variable">${b//hello[0-9]/world-}</span></span><br></pre></td></tr></tbody></table></figure>

<p>其他几个常见用法：</p>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line"><span class="variable">${#name}</span>                  <span class="comment"># name 的长度</span></span><br><span class="line"></span><br><span class="line">expr index <span class="variable">$name</span> <span class="string">"substr"</span> <span class="comment"># 查找子串</span></span><br><span class="line"><span class="variable">$name</span>[(i)<span class="built_in">cd</span>]              <span class="comment"># 查找子串，zsh only; i 从左往右(找不到为0)，I 从右往左(找不到返回原长度+1)</span></span><br><span class="line"></span><br><span class="line"><span class="variable">${name^}</span>    <span class="comment"># 首字母大写    bash 4.0</span></span><br><span class="line"><span class="variable">${name,}</span>    <span class="comment"># 首字母小写    bash 4.0</span></span><br><span class="line"><span class="variable">${name^^}</span>   <span class="comment"># 全大写       bash 4.0</span></span><br><span class="line"><span class="variable">${name,,}</span>   <span class="comment"># 全小写       bash 4.0</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 读取文件内容到字符串</span></span><br><span class="line">content=$(&lt;./aaa.txt)</span><br><span class="line"><span class="keyword">while</span> <span class="built_in">read</span> line; <span class="keyword">do</span> ... <span class="keyword">done</span> &lt; ./aaa.txt            <span class="comment"># 遍历每行</span></span><br><span class="line">IFS=$<span class="string">'\n'</span> &amp;&amp; <span class="keyword">for</span> i <span class="keyword">in</span> $(&lt;./aaa.txt) ; <span class="keyword">do</span> ... <span class="keyword">done</span>   <span class="comment"># 遍历每行</span></span><br><span class="line"><span class="keyword">for</span> line (<span class="variable">${(f)"$(&lt;./aaa.txt)"}</span>) { }                <span class="comment"># 遍历每行，zsh only</span></span><br></pre></td></tr></tbody></table></figure>

<h4 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h4><figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">arr=(penn zshc <span class="string">"cc cc"</span> dddd)    <span class="comment"># 声明</span></span><br><span class="line">files=(./*)                     <span class="comment"># 读取 ./* 命令的结果作为数组</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 读取</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"<span class="variable">${#arr}</span>"</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"<span class="variable">${arr[@]}</span>"</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"<span class="variable">${arr[*]}</span>"</span>                <span class="comment"># 整个数组做为一个参数返回</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"<span class="variable">${arr[0]}</span>"</span></span><br><span class="line"></span><br><span class="line">arr[2]=<span class="string">"cc cc"</span>                  <span class="comment"># 单个item赋值</span></span><br><span class="line">newarr=(<span class="string">"<span class="variable">${arr[@]}</span>"</span> <span class="string">"cc cc"</span>)    <span class="comment"># 连接数组</span></span><br><span class="line">newarr=(<span class="string">"<span class="variable">${arr[@]:1:2}</span>"</span>)        <span class="comment"># 切片</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">unset</span> arr[2]                        <span class="comment"># 删除元素，已有元素的下标志并不会变化</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="string">"<span class="variable">${arr[@]}</span>"</span>; <span class="keyword">do</span> ... <span class="keyword">done</span>   <span class="comment"># 遍历</span></span><br><span class="line">IFS=$<span class="string">'\n'</span> &amp;&amp; sorted=($(sort &lt;&lt;&lt;<span class="string">"<span class="variable">${arr[*]}</span>"</span>)) &amp;&amp; <span class="built_in">unset</span> IFS &amp;&amp; <span class="built_in">echo</span> <span class="string">"<span class="variable">${sorted[@]}</span>"</span>  <span class="comment"># 排序</span></span><br></pre></td></tr></tbody></table></figure>

<h3 id="运算与运算符"><a href="#运算与运算符" class="headerlink" title="运算与运算符"></a>运算与运算符</h3><p>直接调用函数：在当前的进程执行<br>小括号调用函数 <code>$(func)</code>: 在子进程中执行<br>调用脚本 <code>bash aaa.txt</code>：在子进程中执行</p>
<p>[[]]       # 字符串运算命令<br>(())        # 算数运算命令<br>[]          # 执行命令并返回执行结果<br>{}          # zsh：执行命令并返回执行结果 eg <code>if {grep username /etc/passwd}</code><br>()          # zsh：执行并返回执行结果</p>
<h4 id="算数运算"><a href="#算数运算" class="headerlink" title="算数运算"></a>算数运算</h4><p>算数运算符：+、-、*、/、%、=、==、!=</p>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">$((<span class="number">2</span> + <span class="number">3</span> * <span class="number">2</span>))      <span class="comment"># 可以省略空格：$((2+3*2)) </span></span><br></pre></td></tr></tbody></table></figure>

<h4 id="关系运算"><a href="#关系运算" class="headerlink" title="关系运算"></a>关系运算</h4><p>数值的关系运算</p>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment"># 比较运算符： -eq: ==   -ne: !=     -lt: &lt;</span></span><br><span class="line"><span class="comment"># 比较运算符： -gt: &gt;    -le: &lt;=     -ge: &gt;=</span></span><br><span class="line"></span><br><span class="line">[[ 23 -lt 123 ]]    <span class="comment"># true</span></span><br><span class="line">(( 23 &gt; 123))       <span class="comment"># false</span></span><br><span class="line">num1=23</span><br><span class="line">num2=123</span><br><span class="line">((num1 &gt; num2))     <span class="comment"># false</span></span><br></pre></td></tr></tbody></table></figure>

<p>字符串的关系运算</p>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">[[ <span class="string">"a.txt"</span> == a* ]]         <span class="comment"># true 模式匹配</span></span><br><span class="line">[[ <span class="string">"a.txt"</span> =~ .*\.txt ]]    <span class="comment"># true 正则匹配</span></span><br><span class="line">[[ <span class="string">"abc"</span> == abc ]]          <span class="comment"># true 字符串匹配</span></span><br><span class="line">[[ 11 &lt; 2 ]]                <span class="comment"># true 字符串匹配</span></span><br></pre></td></tr></tbody></table></figure>

<p>文件 Metadata 判断</p>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment"># 类型判断符： -b 块设备            -c 字符设备               -d 目录</span></span><br><span class="line"><span class="comment"># 类型判断符： -e 存在的任何文件     -f 普通文件或链接          -g 设置了setgid的文件</span></span><br><span class="line"><span class="comment"># 类型判断符： -h (-L)符号链接      -k 有粘滞位的文件          -p FIFO文件</span></span><br><span class="line"><span class="comment"># 类型判断符： -r 当前进程可读       -s 非空                  -u 设置了setuid的文件</span></span><br><span class="line"><span class="comment"># 类型判断符： -x 当前进程可执行     -w 当前进程可写            -O 当前进程用户拥有</span></span><br><span class="line"><span class="comment"># 类型判断符： -G 当前进程用户组拥有  -S socket文件            -N atime、mtime一样的文件</span></span><br><span class="line"><span class="comment"># 类型判断符： -t 当前进程是否打开fd (0:标准输入，1:标准输出，2:错误输出)</span></span><br><span class="line"></span><br><span class="line">[[ -e /bin/zsh ]]   <span class="comment"># 是否是一个文件</span></span><br><span class="line"></span><br><span class="line">[[ file1 -nt file2 ]]   <span class="comment"># 比较新旧; -ot: 旧于，-nt： 新于</span></span><br><span class="line">[[ file1 -ef file2 ]]   <span class="comment"># 是否是同一个文件；(路径相同或互为硬连接)    </span></span><br></pre></td></tr></tbody></table></figure>

<h4 id="逻辑运算"><a href="#逻辑运算" class="headerlink" title="逻辑运算"></a>逻辑运算</h4><p>逻辑运算符：&amp;&amp; || !</p>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">[[ a1 == a2 &amp;&amp; b1 == b2 ]] <span class="comment"># [[ 、]] 内侧需要空格； == 两侧需要空格；! 在zsh中后面也需要空格</span></span><br></pre></td></tr></tbody></table></figure>

<h3 id="流程控制"><a href="#流程控制" class="headerlink" title="流程控制"></a>流程控制</h3><h4 id="循环"><a href="#循环" class="headerlink" title="循环"></a>循环</h4><ul>
<li>while：</li>
<li>until</li>
<li>for…in</li>
<li>for</li>
<li>select</li>
</ul>
<p>归纳</p>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">while</span> [[ ]]; <span class="keyword">do</span> ... <span class="keyword">done</span>        <span class="comment"># 满足条件时运行</span></span><br><span class="line">until [[ ]]; <span class="keyword">do</span> ... <span class="keyword">done</span>        <span class="comment"># 不满足条件时运行</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> {1..5} ; <span class="keyword">do</span> ... <span class="keyword">done</span>   <span class="comment"># 括号内可以是一个/多个：数组/字符串/哈希表</span></span><br><span class="line"><span class="keyword">for</span> ((;;)); <span class="keyword">do</span> ... <span class="keyword">done</span></span><br><span class="line">select i <span class="keyword">in</span> list <span class="keyword">do</span> ... <span class="keyword">done</span>    <span class="comment"># 提示用户选择</span></span><br></pre></td></tr></tbody></table></figure>

<p>举例：<a href="https://wangdoc.com/bash/loop.html">这里</a></p>
<h4 id="分支"><a href="#分支" class="headerlink" title="分支"></a>分支</h4><p>归纳</p>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> condition; <span class="keyword">then</span> ... [<span class="keyword">elif</span> condition; <span class="keyword">then</span> ... ] [<span class="keyword">else</span> ... ] <span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> expression <span class="keyword">in</span></span><br><span class="line">  pattern )</span><br><span class="line">    ... ;;</span><br><span class="line">  pattern )</span><br><span class="line">    ... ;;</span><br><span class="line">  *)</span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">esac</span></span><br></pre></td></tr></tbody></table></figure>

<p>举例：<a href="https://wangdoc.com/bash/condition.html">这里</a></p>
<h4 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h4><figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">foo</span></span>(){}    <span class="comment"># 定义函数</span></span><br><span class="line"><span class="built_in">unset</span> foo           <span class="comment"># 删除函数</span></span><br><span class="line">decleare -f         <span class="comment"># 查看函数定义</span></span><br><span class="line">foo <span class="variable">${arr[@]}</span>       <span class="comment"># 调用函数，参数 arr</span></span><br><span class="line"><span class="built_in">local</span> aa=123        <span class="comment"># 定义局部变量</span></span><br><span class="line"><span class="built_in">return</span> 10           <span class="comment"># 函数返回值</span></span><br><span class="line"><span class="variable">$#</span>                  <span class="comment"># 参数的长度</span></span><br></pre></td></tr></tbody></table></figure>

<h3 id="通配符"><a href="#通配符" class="headerlink" title="通配符"></a>通配符</h3><figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">*           <span class="comment"># 任意字符串</span></span><br><span class="line">?           <span class="comment"># 单个字符</span></span><br><span class="line">[abc]       <span class="comment"># abc中的任意字符</span></span><br><span class="line">[^abc]      <span class="comment"># 非abc字符</span></span><br><span class="line">[a-c0-9zx]  <span class="comment"># 字符范围</span></span><br></pre></td></tr></tbody></table></figure>
]]></content>
      <categories>
        <category>Linux</category>
        <category>Shell</category>
      </categories>
      <tags>
        <tag>Shell</tag>
        <tag>Bash</tag>
      </tags>
  </entry>
  <entry>
    <title>Shell (Bash) 编程（篇二）： 一些技巧</title>
    <url>/posts/7e3a/</url>
    <content><![CDATA[<p>看到了别人写的很不错的 blog，收藏了备忘</p>
<span id="more"></span>

<hr>
<p><a href="http://mywiki.wooledge.org/BashGuide">mywiki.wooledge.org/BashGuide</a>: 一个循序渐进的 bash 教程</p>
<p><a href="http://mywiki.wooledge.org/BashPitfalls">mywiki.wooledge.org: BashPitfalls</a>: 写出了很多的 bush 常见的坑<br>其译文：<a href="https://kodango.com/bash-pitfalls-part-1">kodango.com</a></p>
<p><a href="https://github.com/koalaman/shellcheck">shellcheck</a>：一个静态分析工具，可以辅助写 bash 脚本。</p>
]]></content>
      <categories>
        <category>Linux</category>
        <category>Shell</category>
      </categories>
      <tags>
        <tag>Shell</tag>
        <tag>Bash</tag>
        <tag>收藏</tag>
      </tags>
  </entry>
  <entry>
    <title>Ubuntu 软路由（篇二）：v2ray 与透明（全局）代理</title>
    <url>/posts/5393/</url>
    <content><![CDATA[<p>如何在路由器上配置全局透明代理，以免被防火墙误伤。</p>
<span id="more"></span>

<hr>
<p>接上一篇：<a href="../df8b/">Ubuntu 软路由（篇一）：配置基于 ubuntu 的软路由</a></p>
<p>最早的时候，我使用了 shadowsocks 为基础的端口转发方案，但是配置复杂且不稳定。<br>这里使用的是 V2Ray + iptables 的转发方案。实际上由于 V2ray 支持路由，做网络的分流会方便很多，也更容易管理。</p>
<h2 id="安装、配置V2Ray"><a href="#安装、配置V2Ray" class="headerlink" title="安装、配置V2Ray"></a>安装、配置 V2Ray</h2><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p>下载解压稳定的 v2ray 文件到安装目录，我这里用的是 <code>/home/ubuntu/app/install/v2ray</code>。为了获取稳定的新版本，我使用的是从 github 仓库下载的最后一版，<a href="https://github.com/v2fly/v2ray-core/releases">仓库地址</a></p>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> /home/ubuntu/app/install</span><br><span class="line">wget https://github.com/v2fly/v2ray-core/releases/download/v4.33.0/v2ray-linux-64.zip</span><br><span class="line">unzip -d v2ray v2ray-linux-64.zip</span><br></pre></td></tr></tbody></table></figure>

<p>解压之后目录内容如下：</p>
<p><code>/home/ubuntu/app/install/v2ray</code> :</p>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">├── config.json</span><br><span class="line">├── geoip.dat</span><br><span class="line">├── geosite.dat</span><br><span class="line">├── systemd</span><br><span class="line">│&nbsp;&nbsp; └── system</span><br><span class="line">│&nbsp;&nbsp;     ├── v2ray.service</span><br><span class="line">│&nbsp;&nbsp;     └── v2ray@.service</span><br><span class="line">├── v2ctl</span><br><span class="line">├── v2ray</span><br><span class="line">├── vpoint_socks_vmess.json</span><br><span class="line">└── vpoint_vmess_freedom.json</span><br></pre></td></tr></tbody></table></figure>

<p>接下来准备 systemd 的服务注册文件（用于将 v2ray 注册称一个服务以便自启动）,<br>修改文件 <code>/home/ubuntu/app/install/v2ray/systemd/system/v2ray.service</code>, 原内容如下：</p>
 <figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">[Unit]</span><br><span class="line">Description=V2Ray Service</span><br><span class="line">Documentation=https://www.v2fly.org/</span><br><span class="line">After=network.target nss-lookup.target</span><br><span class="line"></span><br><span class="line">[Service]</span><br><span class="line">User=nobody</span><br><span class="line">CapabilityBoundingSet=CAP_NET_ADMIN CAP_NET_BIND_SERVICE</span><br><span class="line">AmbientCapabilities=CAP_NET_ADMIN CAP_NET_BIND_SERVICE</span><br><span class="line">NoNewPrivileges=true</span><br><span class="line">ExecStart=/usr/local/bin/v2ray -config /usr/local/etc/v2ray/config.json</span><br><span class="line">Restart=on-failure</span><br><span class="line">RestartPreventExitStatus=23</span><br><span class="line"></span><br><span class="line">[Install]</span><br><span class="line">WantedBy=multi-user.target</span><br></pre></td></tr></tbody></table></figure>

<p>有两处需要修改：</p>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment"># ExecStart... 启动命令，修改启动文件位置、配置文件位置：</span></span><br><span class="line">ExecStart=/home/ubuntu/app/install/v2ray/v2ray -config /home/ubuntu/app/install/v2ray/config.json</span><br></pre></td></tr></tbody></table></figure>

<p>接下来将 v2ray 注册到 systemd,<br>（这里每次修改 service 文件之后都需要重新执行这个操作）</p>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment"># 将service文件复制到系统的service文件存放位置</span></span><br><span class="line">cp /home/ubuntu/app/install/v2ray/systemd/system/v2ray.service /etc/systemd/system/v2ray.service</span><br><span class="line"><span class="comment"># 更新service目录</span></span><br><span class="line">sudo systemctl daemon-reload</span><br><span class="line"><span class="comment"># 启动v2ray</span></span><br><span class="line">sudo systemctl start v2ray.service</span><br></pre></td></tr></tbody></table></figure>

<p>查看 v2ray 运行状态：</p>
<p><code>sudo systemctl status v2ray.service</code></p>
<p>如下 log，当 Active 状态是 active 时，启动完成。</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">● v2ray.service - V2Ray Service</span><br><span class="line">     Loaded: loaded (/etc/systemd/system/v2ray.service; enabled; vendor preset: enabled)</span><br><span class="line">     Active: active (running) since Mon 2021-03-15 00:53:22 CST; 4h 5min ago</span><br><span class="line">       Docs: https://www.v2ray.com/</span><br><span class="line">             https://www.v2fly.org/</span><br><span class="line">   Main PID: 56320 (v2ray)</span><br><span class="line">      Tasks: 11 (limit: 4501)</span><br><span class="line">     Memory: 27.7M</span><br><span class="line">     CGroup: /system.slice/v2ray.service</span><br><span class="line">             └─56320 /home/ubuntu/app/install/v2ray/v2ray -c /home/ubuntu/app/v2ray.json</span><br></pre></td></tr></tbody></table></figure>

<h3 id="配置v2ray"><a href="#配置v2ray" class="headerlink" title="配置v2ray"></a>配置 v2ray</h3><p>记录一下简要的配置备忘：<br>为了可读性和维护性，我用了 yaml 记录配置文件。v2ray 实际并不支持 yaml 格式的配置文件，将 yaml 先转成 json 才能够正常使用。</p>
<p>yaml 转 json： <code>yq -j eval my_config.yaml &gt; my_config.json</code></p>
<figure class="highlight yaml"><table><tbody><tr><td class="code"><pre><span class="line"><span class="attr">log:</span></span><br><span class="line">  <span class="attr">access:</span>  <span class="string">/dev/null</span>            <span class="comment"># 输出到空设备（丢弃），留空时将输出到 stdout</span></span><br><span class="line">  <span class="attr">error:</span> <span class="string">/home/ubuntu/app/log/v2ray/error.log</span> <span class="comment"># 留空时将输出到 stdout</span></span><br><span class="line">  <span class="attr">logLevel:</span> <span class="string">warning</span>             <span class="comment"># debug|info|warning|error|none # 默认waring</span></span><br><span class="line"><span class="attr">inbounds:</span> <span class="string">入口</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">tag:</span> <span class="string">in_transparent</span>         <span class="comment"># dokodemo-door 协议的inbound，用于透明代理流量</span></span><br><span class="line">    <span class="attr">port:</span> <span class="number">1081</span>                  <span class="comment"># 使用环境变量: env:MY_V2RAY_PORT</span></span><br><span class="line">    <span class="attr">listen:</span> <span class="number">192.68</span><span class="number">.1</span><span class="number">.1</span>          <span class="comment"># 默认 0.0.0.0</span></span><br><span class="line">    <span class="attr">protocol:</span> <span class="string">dokodemo-door</span>     <span class="comment"># blackhole|dokodemo-door|freedom|http|shadowsocks|socks|vmess</span></span><br><span class="line">    <span class="attr">settings:</span>                   <span class="comment"># 具体的配置内容，视协议而定</span></span><br><span class="line">      <span class="attr">network:</span> <span class="string">tcp,udp</span></span><br><span class="line">      <span class="attr">followRedirect:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">sniffing:</span>                   <span class="comment"># 探测流量，根据目的地址重制连接的目标</span></span><br><span class="line">      <span class="attr">enabled:</span> <span class="literal">true</span></span><br><span class="line">      <span class="attr">destOverride:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">http</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">tls</span></span><br><span class="line">    <span class="attr">streamSettings:</span>             <span class="comment"># 底层传输配置，优先于全局的传输配置</span></span><br><span class="line">      <span class="attr">sockopt:</span></span><br><span class="line">        <span class="attr">tproxy:</span> <span class="string">redirect</span></span><br><span class="line"><span class="attr">outbounds:</span>                      <span class="comment"># rules没有匹配到的流量默认走第一个outbound</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">tag:</span> <span class="string">out_direct</span></span><br><span class="line">    <span class="attr">protocol:</span> <span class="string">freedom</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">tag:</span> <span class="string">&amp;my_server_tag</span> <span class="string">my_server_tag</span></span><br><span class="line">    <span class="attr">protocol:</span> <span class="string">vmess</span></span><br><span class="line">    <span class="attr">sendThrough:</span> <span class="number">0.0</span><span class="number">.0</span><span class="number">.0</span></span><br><span class="line">    <span class="attr">settings:</span></span><br><span class="line">      <span class="attr">vnext:</span>                <span class="comment"># 以下是服务器信息</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">address:</span> <span class="string">my_server.com</span></span><br><span class="line">          <span class="attr">port:</span> <span class="number">2048</span></span><br><span class="line">          <span class="attr">users:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="attr">id:</span> <span class="string">aaaaaaaa-aaaa-aaaa-aaaaa-aaaaaaaaaaaaa</span></span><br><span class="line">              <span class="attr">alterId:</span> <span class="number">64</span></span><br><span class="line">    <span class="attr">streamSettings:</span></span><br><span class="line">      <span class="attr">network:</span> <span class="string">tcp</span>          <span class="comment"># 默认tcp， tcp|kcp|ws|http|domainsocket,</span></span><br><span class="line">      <span class="attr">sockopt:</span></span><br><span class="line">        <span class="attr">mark:</span> <span class="number">0</span>             <span class="comment"># 非0时，在传出连接上标记 SO_MARK</span></span><br><span class="line">        <span class="attr">tcpFastOpen:</span> <span class="literal">false</span></span><br><span class="line">    <span class="attr">mux:</span>                    <span class="comment"># 用于在一条TCP数据连接上承载多条逻辑TCP链路，可以加速握手</span></span><br><span class="line">      <span class="attr">enabled:</span> <span class="literal">true</span></span><br><span class="line">      <span class="attr">concurrency:</span> <span class="number">4</span>        <span class="comment"># 默认8，范围：[1,1024]，-1 表示加载Mux模块</span></span><br><span class="line"><span class="attr">routing:</span></span><br><span class="line">  <span class="attr">domainStrategy:</span> <span class="string">IPIfNonMatch</span></span><br><span class="line">  <span class="attr">rules:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">type:</span> <span class="string">field</span>       <span class="comment"># 通过域名匹配国外流量: 常用的网站集合</span></span><br><span class="line">      <span class="attr">domain:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">geosite:google</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">geosite:facebook</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">geosite:geolocation-!cn</span></span><br><span class="line">      <span class="attr">outboundTag:</span> <span class="meta">*my_server_tag</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">type:</span> <span class="string">field</span>        <span class="comment"># 通过域名匹配国外流量：自定义域名</span></span><br><span class="line">      <span class="attr">domain:</span>            <span class="comment"># 可以添加自己的域名：</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">firecore.com</span>   <span class="comment"># infuse 官网</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">thetvdb.com</span>    <span class="comment"># jellyfin 刷新元数据用</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">themoviedb.org</span> <span class="comment"># jellyfin 刷新元数据用</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">omdbapi.com</span>    <span class="comment"># jellyfin 刷新元数据用</span></span><br><span class="line">      <span class="attr">outboundTag:</span> <span class="meta">*my_server_tag</span></span><br><span class="line"><span class="attr">transport:</span>               <span class="comment"># 传输设置，暂留空</span></span><br><span class="line"><span class="attr">policy:</span>                  <span class="comment"># 本地策略，暂留空</span></span><br></pre></td></tr></tbody></table></figure>

<p>之后重启 v2ray 即可生效: <code>sudo systemctl restart v2ray.service</code>。</p>
<h2 id="配置iptables"><a href="#配置iptables" class="headerlink" title="配置iptables"></a>配置 iptables</h2><p>v2ray 已经运行起来，还需要将路由器收到的流量转发至 v2ray 监听的端口，让 v2ray 来接管需要代理的流量：</p>
<p>这里用一条明叫 V2RAY 的链来过滤需要被接管的流量，过滤不通过的流量会按照默认规则路由，不会走到 V2ray：</p>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment"># 首先清空这条链（不存在会报错）</span></span><br><span class="line">sudo iptables -t nat -F V2RAY</span><br><span class="line"><span class="comment"># 新建链</span></span><br><span class="line">sudo iptables -t nat -N V2RAY</span><br><span class="line"></span><br><span class="line"><span class="comment"># 私有IP处理，RETURN: 过滤不通过，返回</span></span><br><span class="line">sudo iptables -t nat -A V2RAY -d 0/8 -j RETURN</span><br><span class="line">sudo iptables -t nat -A V2RAY -d 10/8 -j RETURN</span><br><span class="line">sudo iptables -t nat -A V2RAY -d 127/8 -j RETURN</span><br><span class="line">sudo iptables -t nat -A V2RAY -d 169.254/16 -j RETURN</span><br><span class="line">sudo iptables -t nat -A V2RAY -d 172.16/12 -j RETURN</span><br><span class="line">sudo iptables -t nat -A V2RAY -d 192.168/16 -j RETURN</span><br><span class="line">sudo iptables -t nat -A V2RAY -d 224/4 -j RETURN</span><br><span class="line">sudo iptables -t nat -A V2RAY -d 240/4 -j RETURN</span><br><span class="line">sudo iptables -t nat -A V2RAY -d 255.255.255/32 -j RETURN</span><br><span class="line"></span><br><span class="line"><span class="comment"># 其他不想要代理的IP：</span></span><br><span class="line"><span class="comment"># 这里一定需要将代理服务器的IP加进来(如果服务器是域名参考后面的说明)：</span></span><br><span class="line">sudo iptables -t nat -A V2RAY -s my_v2ray_remote_server_ip -j RETURN </span><br><span class="line">sudo iptables -t nat -A V2RAY -s 10.10.20.11 -j RETURN </span><br><span class="line">sudo iptables -t nat -A V2RAY -s 10.10.20.12 -j RETURN </span><br><span class="line"></span><br><span class="line"><span class="comment"># 需要代理的流量转发至V2ray的端口：1081，以下两行分别设置通过单个IP匹配、通过网络号匹配：</span></span><br><span class="line">sudo iptables -t nat -A V2RAY -s 10.10.21.0/24 -p tcp -j REDIRECT --to-ports 1081</span><br><span class="line">sudo iptables -t nat -A V2RAY -s 10.10.22.2    -p tcp -j REDIRECT --to-ports 1081</span><br><span class="line"></span><br><span class="line"><span class="comment"># 也可以直接设置剩下的所有流量全部转发，需要谨慎使用：</span></span><br><span class="line"><span class="comment"># sudo iptables -t nat -A V2RAY -p tcp -j REDIRECT --to-ports 1081</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 将 POSTROUTING &amp; OUTPUT 链的流量转发到V2RAY，具体只是搜索：iptable三表五链</span></span><br><span class="line">sudo iptables -t nat -A PREROUTING -p tcp -j V2RAY</span><br><span class="line">sudo iptables -t nat -A OUTPUT -p tcp -j V2RAY</span><br></pre></td></tr></tbody></table></figure>

<p>备份修改后的 iptables</p>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">sudo /bin/bash /home/root/myipset.bash backup</span><br></pre></td></tr></tbody></table></figure>

<p>具体参考上一篇 blog.</p>
<p>至此，被代理的主机已经可以无感穿过防火墙了。</p>
<h2 id="iptables规则过滤域名"><a href="#iptables规则过滤域名" class="headerlink" title="iptables规则过滤域名"></a>iptables 规则过滤域名</h2><p>iptables 仅能够过滤 IP，但是可以通过曲线救国手段过滤某些域名。<br>这个曲线救国的工具就是 ipset ubuntu 默认不带，需要先安装:</p>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">sudo apt-get install ipset -y</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建一个ipset(本质就是一个ip的列表)</span></span><br><span class="line">sudo ipset create my-v2ray-ip-list <span class="built_in">hash</span>:ip</span><br></pre></td></tr></tbody></table></figure>

<p>编辑 dnsmasq 的配置文件：<code>sudo vim /etc/dnsmasq.conf</code><br>追加写入：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line"># 用于将域名 v2ray_server_host 匹配到的域名的ip写入 my-v2ray-ip-list 中</span><br><span class="line"># 距离 baidu.com 可以匹配到 baidu.com, pan.baidu.com 等。</span><br><span class="line">ipset=/v2ray_server_host/my-v2ray-ip-list</span><br></pre></td></tr></tbody></table></figure>

<p>之后重启 dnsmasq 服务即可生效 <code>systemctl restart dnsmasq.service</code>。</p>
<h2 id="持久化-ipset-的配置"><a href="#持久化-ipset-的配置" class="headerlink" title="持久化 ipset 的配置"></a>持久化 ipset 的配置</h2><p>由于 ipset 关机会丢失，这里为它写一个自动保存和加载的脚本，参考上一篇中 iptables 的脚本。</p>
<p>service 文件路径 /etc/systemd/system/myipset.service<br>处理 ipset 的脚本路径 /home/root/ipset.bash<br>ipset 备份文件保存路径 /home/root/backup.ipset.ipv4</p>
<p>创建文件 service 文件，内容如下:</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">[Unit]</span><br><span class="line">Description=backup ipset when shutdown &amp; restore ipset when boot</span><br><span class="line">Before=myiptables.service</span><br><span class="line"></span><br><span class="line">[Service]</span><br><span class="line">Type=oneshot</span><br><span class="line">RemainAfterExit=true</span><br><span class="line">ExecStart=/bin/bash /home/root/ipset.bash restore</span><br><span class="line">ExecStop=/bin/bash /home/root/ipset.bash backup</span><br><span class="line"></span><br><span class="line">[Install]</span><br><span class="line">WantedBy=multi-user.target</span><br></pre></td></tr></tbody></table></figure>

<p>上面用到的保存 ipset 数据的脚本 ipset.bash 内容如下，</p>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">default_backup_file=<span class="string">"/home/root/backup.ipset.ipv4"</span> <span class="comment"># 关机时备份文件的位置，需要自定义</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"<span class="variable">$default_backup_file</span>"</span></span><br><span class="line"></span><br><span class="line">action=<span class="variable">$1</span></span><br><span class="line">backup_file=<span class="variable">${2:-<span class="variable">$default_backup_file</span>}</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> [ ! <span class="string">"<span class="variable">${backup_file}</span>"</span> ]; <span class="keyword">then</span></span><br><span class="line">  <span class="built_in">echo</span> <span class="string">"param 2 error: should not empty."</span></span><br><span class="line">  <span class="built_in">exit</span> 1</span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"><span class="keyword">if</span> [ <span class="string">"<span class="variable">$action</span>"</span> == <span class="string">'restore'</span> ]; <span class="keyword">then</span></span><br><span class="line">  /sbin/ipset restore &lt;<span class="string">"<span class="variable">${backup_file}</span>"</span></span><br><span class="line">  <span class="built_in">exit</span> 0</span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"><span class="keyword">if</span> [ <span class="string">"<span class="variable">$action</span>"</span> == <span class="string">'backup'</span> ]; <span class="keyword">then</span></span><br><span class="line">  ensure_dir_exist <span class="string">"<span class="subst">$(dirname <span class="string">"<span class="variable">$backup_file</span>"</span>)</span>"</span></span><br><span class="line">  /sbin/ipset save &gt;<span class="string">"<span class="variable">$backup_file</span>"</span></span><br><span class="line">  <span class="built_in">exit</span> 0</span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"><span class="built_in">echo</span> backup_file path: <span class="string">"<span class="variable">${default_backup_file}</span>"</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"user param: 'backup' or 'restore'"</span></span><br><span class="line"><span class="built_in">exit</span> 1</span><br></pre></td></tr></tbody></table></figure>

<p>保存好脚本<br>之后手动保存一次 ipset 的数据： ipset save &gt; /home/root/backup.ipset.ipv4<br>接下来开始激活 ipset.service：</p>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">sudo systemctl daemon-reload <span class="comment"># systemd刷新service文件</span></span><br><span class="line">sudo systemctl <span class="built_in">enable</span> myipset <span class="comment"># 启用开机自启动 myipset</span></span><br><span class="line">sudo systemctl start myipset <span class="comment"># 运行 myipset</span></span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>

<p>重新开关机之后也可以正常运行了。</p>
]]></content>
      <categories>
        <category>Linux</category>
        <category>Router</category>
      </categories>
      <tags>
        <tag>Router(软路由)</tag>
      </tags>
  </entry>
  <entry>
    <title>如何深入学习一种编程语言？</title>
    <url>/posts/ee65/</url>
    <content><![CDATA[<p>结合自己学习、带实习生的一些经验总结的学习一门编程语言的切入方向。</p>
<span id="more"></span>

<hr>
<p>本文可以作为学习语言的路书，当然只能作为指导原则，细节还需要参照具体语言决定。也可以作为自查工具，看看自己还有那些漏掉的地方。<br>基本上参考了一下几年来我接触到的几种语言的特性：JavaScript, Node.js, Golang, Java, Python。</p>
<p>总结的不完善，将来想到的时候再补充吧。</p>
<h3 id="学习新语言的步骤"><a href="#学习新语言的步骤" class="headerlink" title="学习新语言的步骤"></a>学习新语言的步骤</h3><ol>
<li>平台与特性</li>
<li>包管理机制</li>
<li>数据与运算</li>
<li>流程与控制</li>
<li>内建工具和包装类型</li>
<li>封装和抽象</li>
<li>测试与异常</li>
<li>扩展</li>
</ol>
<h3 id="平台与特性"><a href="#平台与特性" class="headerlink" title="平台与特性"></a>平台与特性</h3><ul>
<li>平台的设计<ul>
<li>面向领域</li>
<li>性能</li>
</ul>
</li>
<li>语言特性<ul>
<li>编译型，解释型</li>
<li>静态类型 / 动态类型</li>
<li>强类型 / 弱类型</li>
<li>函数式 / 过程式 / 对象式</li>
</ul>
</li>
</ul>
<p>语言的设计领域决定了其使用成本，比如开发 Web 项目，使用 Go，Node.js 等内置 HTTP API 的语言肯定要比 C++ 一类的语言使用成本更低。当然，像是 Java 这种有完善的 HTTP 开发框架，开发效率也会很高。</p>
<p>性能比较好理解，通常来说，语言越高级越自动化，性能相对越差。这里提供一个 Debian 团队的语言 Benchmark 项目的 <a href="https://benchmarksgame-team.pages.debian.net/benchmarksgame/index.html">连接</a> , 这里记录了大部分语言的 benchmark 信息。可以作为理解语言定位的参考。</p>
<p>编译（解释）方式、动态 / 静态、强 / 弱类型等语言特性很大程度上影响了该语言的程序设计思想。当我选用 Node.js 开发项目时，我可以相对随意的设计和运行程序。但是 Java 或者 C 就相对严肃，我需要严格的按照范式进行，否则根本跑不起来。</p>
<p>不是所有的特性每种语言都有完整的支持，没有的或者没有写到的也不用奇怪。</p>
<h3 id="包管理机制"><a href="#包管理机制" class="headerlink" title="包管理机制"></a>包管理机制</h3><p>个人觉得包管理机制因该优先于语法学习。个人也推崇自顶向下的学习理念。<br>只有宏观了解代码运行和组织方式之后，再深入微观才能有比较好的理解。</p>
<ul>
<li>包管理工具</li>
<li>第三方仓库的查询，安装</li>
<li>私有仓库的使用方法</li>
</ul>
<p>不管会不会 Nodejs 都值得一试的 Nodejs 的包管理器：NPM</p>
<h3 id="数据与运算"><a href="#数据与运算" class="headerlink" title="数据与运算"></a>数据与运算</h3><p>这里语言的基础语法层面的知识，是熟练使用的前提。通常来说，各种语言在这个领域类似但是不相同。<br>需要注意的点如下</p>
<ul>
<li>基础语法<ul>
<li>语言结构<ul>
<li>文件命名，语句写法</li>
<li>标识符：大小写敏感</li>
</ul>
</li>
</ul>
</li>
<li>数据与表示<ul>
<li>数据的类型<ul>
<li>基础类型：默认值 字节数 取值范围<ul>
<li>数字型：short, int, long, float, double</li>
<li> 非数字型：byte, boolean, char</li>
</ul>
</li>
<li> 高级类型<ul>
<li>字符类型：string<ul>
<li> 操作：连接，查找，替换，trim, 大小写转换，split, 模版替换</li>
</ul>
</li>
<li>包装类型：基础类型的衍生</li>
</ul>
</li>
<li>基础类型转换<ul>
<li>隐式转换<ul>
<li> number 转: string boolean byte char</li>
<li>string 转: number boolean byte char</li>
<li>byte   转: string char</li>
<li>char   转: string int</li>
</ul>
</li>
<li> 显式转换</li>
</ul>
</li>
<li>集合类型<ul>
<li>枚举，bitSet (位集), vector (向量), stack, array, map, slice<ul>
<li> 多维，遍历，查找，排序，比较，删除，插入，过滤</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>数据的表示<ul>
<li>变量，常量</li>
<li>语法：声明，声明并赋值</li>
<li>作用域<ul>
<li>范围：全局，局部，模块作用域</li>
<li>闭包</li>
</ul>
</li>
<li>转义: <code>\t \b 后退符 \n 换行符 \r 回车符 \f 换页符 \' \" \\</code></li>
</ul>
</li>
</ul>
</li>
<li>数据的计算<ul>
<li>运算<ul>
<li>运算符号<ul>
<li>算数运算：<code>+ - * / % ++ --</code></li>
<li>关系元算：<code>== != &gt; &lt; &gt;= &lt;=</code></li>
<li>位运算: <code>&amp; | ^(异或) ~(按位取反) &lt;&lt; &gt;&gt; &gt;&gt;&gt;</code></li>
<li>逻辑运算: <code>&amp;&amp; || !</code></li>
<li>赋值运算: <code>= += -= *= /= %= &lt;&lt;= &gt;&gt;= &amp;= ^= |=</code></li>
<li>三元运算符: <code>?:</code></li>
<li>类型运算符: <code>instanceof</code></li>
</ul>
</li>
<li>运算符优先级<ul>
<li>以 java 为例，优先级按顺序展开：<ul>
<li>后缀: <code>() [] . (点操作符)</code></li>
<li>一元: <code>++ -- +(正号) -（负号） ~ !</code></li>
<li>乘性: <code>* / %</code></li>
<li>加性: <code>+ -</code></li>
<li>位移: <code>&gt;&gt; &gt;&gt;&gt; &lt;&lt;</code></li>
<li>关系: <code>&gt; &gt;= &lt; &lt;=</code></li>
<li>相等: <code>== !=</code></li>
<li>按位与 <code>&amp;</code> &gt; 按位异或 <code>^</code> &gt; 按位或 <code>|</code></li>
<li>逻辑与 <code>&amp;&amp;</code> &gt; 逻辑或 <code>||</code></li>
<li>条件: <code>? :</code></li>
<li>赋值: <code>= += -= *= /= %= &gt;&gt;= &lt;&lt;= &amp;= ^= |=</code></li>
<li>逗号: <code>,</code></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="流程与控制"><a href="#流程与控制" class="headerlink" title="流程与控制"></a>流程与控制</h3><ul>
<li>循环<ul>
<li>条件循环: for wihle</li>
<li> 迭代器</li>
<li>中断 break</li>
<li> 跳过 continue</li>
</ul>
</li>
<li> 分支<ul>
<li>两个出口的分支: if</li>
<li> 多个出口的分支: if switch—case</li>
</ul>
</li>
<li> 暂停</li>
<li>阻塞（等待）</li>
</ul>
<h3 id="内建工具和包装类型"><a href="#内建工具和包装类型" class="headerlink" title="内建工具和包装类型"></a>内建工具和包装类型</h3><p>这部分是常见的自带的库的用法，写的不完善，可以根据需要参考语言文档按需选择。</p>
<ul>
<li>number 包装类型<ul>
<li> Short Integer Long Byte Double Float</li>
</ul>
</li>
<li>Math 计算工具<ul>
<li>数值计算: abs ceil (上取整) floor rint (最接近的整数) round min max exp (e 的 a 次方) pow (a 的 b 次方) sqrt</li>
<li> 三角函数: sin cos tan acos atan atan2 toDegrees toRadians</li>
<li> 其他: random</li>
</ul>
</li>
<li>Charactor 类<ul>
<li>转义字符</li>
<li>操作: isLetter isDigit isWhitespace isUpperCase isLowerCase toString</li>
</ul>
</li>
<li>String StringBuffer StringBuilder<ul>
<li> 连接 查找 替换 trim 大小写转换 substring split</li>
</ul>
</li>
<li>Date 的使用<ul>
<li>时间戳 时区转化 格式化 比较 计算</li>
<li>用 string 转换</li>
<li>格式化编码<ul>
<li> G 纪元标记 AD</li>
<li>y 四位年份 2001</li>
<li>M 月份 July or 07</li>
<li>d 一个月的日期 10</li>
<li>h  A.M./P.M. (1~12) 格式小时 12</li>
<li>H 一天中的小时 (0~23) 22</li>
<li>m 分钟数 30</li>
<li>s 秒数 55</li>
<li>S 毫秒数 234</li>
<li>E 星期几 Tuesday</li>
<li>D 一年中的日子 360</li>
<li>F 一个月中第几周的周几 2 (second Wed. in July)</li>
<li>w 一年中第几周 40</li>
<li>W 一个月中第几周 1</li>
<li>a A.M./P.M. 标记 PM</li>
<li>k 一天中的小时 (1~24) 24</li>
<li>K  A.M./P.M. (0~11) 格式小时 10</li>
<li>z 时区 Eastern Standard Time</li>
<li>‘ 文字定界符 Delimiter</li>
<li>“ 单引号 `</li>
</ul>
</li>
</ul>
</li>
<li> 正则表达式<ul>
<li> match<ul>
<li> 一般字符 <code>. \d  \D \s \S \w \W</code></li>
<li>不可见字符 <code>^ $ \f 换页符 \n \r \t \v  \b 字符边界 \B 非边界</code></li>
<li>其他<ul>
<li><code>\cx  控制符(\cm 表示 ctrl+M）</code></li>
<li><code>\xn  十六进制字符："\x41"匹配"A</code></li>
<li><code>\num 匹配重复次数: "(.)\1"匹配两个连续的相同字符</code></li>
<li><code>\un  匹配十六进制unicode字符: \u00A9 匹配版权符号©</code></li>
</ul>
</li>
<li>组合 <code>x|y [xyz] [^xyz] [a-z] [^a-z] (pattern)</code></li>
</ul>
</li>
<li>count: <code>* + ? {n} {n,} {n,m}</code></li>
<li>模式<ul>
<li><code>?</code> 表示非贪心，如 <code>*? +? {n}? {n,}? {n,m}?</code></li>
<li><code>(?:pattern)</code> 匹配但是不捕获 <code>industr(?:y|ies)</code> 是比 ‘industry|industries’ 更经济的表达式</li>
<li><code>(?=pattern)</code> 匹配 pattern 结尾的表达式<ul>
<li><code>Windows (?=95|98|NT|2000)</code> 匹配”Windows 2000” 中的”Windows”</li>
<li> 不匹配”Windows 3.1” 中的”Windows”</li>
</ul>
</li>
<li><code>(?!pattern)</code> 匹配不以 pattern 结尾的表达式<ul>
<li><code>Windows (?!95|98|NT|2000)</code> 匹配”Windows 3.1” 中的 “Windows”</li>
<li> 不匹配”Windows 2000” 中的”Windows”</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li> 流处理</li>
<li>文件处理</li>
<li> IO</li>
<li> 控制台交互</li>
<li> socket</li>
</ul>
<h3 id="封装和抽象"><a href="#封装和抽象" class="headerlink" title="封装和抽象"></a>封装和抽象</h3><ul>
<li>method<ul>
<li> 声明</li>
<li>调用</li>
</ul>
</li>
<li>对象</li>
<li>模块</li>
<li>面向对象设计<ul>
<li>继承</li>
<li>多态</li>
<li>接口</li>
</ul>
</li>
<li>范型：描述算法忽略类型的工具，描述时忽略类型，使用算法时来再来确定类型</li>
</ul>
<p>对于静态类型的语言来说，没有范型简直就是灾难。说的就是你: Go。</p>
<h3 id="测试与异常"><a href="#测试与异常" class="headerlink" title="测试与异常"></a>测试与异常</h3><ul>
<li>测试方法（单元测试）</li>
<li>同步异常</li>
<li>异步异常</li>
</ul>
<h3 id="功能扩展"><a href="#功能扩展" class="headerlink" title="功能扩展"></a>功能扩展</h3><ul>
<li>序列化</li>
<li>多线程</li>
<li>文档提取</li>
<li>代码混淆</li>
<li>语言风格</li>
</ul>
]]></content>
      <categories>
        <category>learn</category>
      </categories>
      <tags>
        <tag>learn</tag>
      </tags>
  </entry>
  <entry>
    <title>Ubuntu 软路由（篇一）：配置基于 ubuntu 的软路由</title>
    <url>/posts/df8b/</url>
    <content><![CDATA[<p>将 Ubuntu 主机配置成一台路由器。</p>
<span id="more"></span>

<hr>
<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>主要实现功能</p>
<ul>
<li>准备硬件：一台具有多个网口的 ubuntu 主机 (以 <strong>ubuntu server 20.04</strong> 版本举例)</li>
<li> 配置路由机的路由表</li>
<li>路由机开启端口转发功能</li>
<li>路由机安装域名服务器</li>
<li>路由机安装 DHCP 服务</li>
<li>路由机 重启加载 iptables 规则</li>
</ul>
<p>机器的硬件信息</p>
<ul>
<li>路由机（列出 mac 地址以供后续使用）<ul>
<li>enp0s1 XX:XX:XX:XX:XX:01</li>
<li>enp0s2 XX:XX:XX:XX:XX:02</li>
<li>enp0s3 XX:XX:XX:XX:XX:03</li>
</ul>
</li>
</ul>
<p>计划</p>
<ul>
<li>将 enp0s1 作为 wan 口</li>
<li>将 enp0s2, lenp0s3 作为 lan 口</li>
<li> DHCP 服务监听在 lan 口上</li>
</ul>
<hr>
<h2 id="具体步骤"><a href="#具体步骤" class="headerlink" title="具体步骤"></a>具体步骤</h2><h3 id="为网卡改名"><a href="#为网卡改名" class="headerlink" title="为网卡改名"></a>为网卡改名</h3><p>ubuntu20.04 中使用 netplan 来配置网络信息，其配置文件为  <code>/etc/netplan/00-installer-config.yaml</code> （名称可能为任何 xxx.yaml）<br>编辑 netplan 配置文件，将  <code>ethernets</code> 字段改为如下：<br>保存之后使用  <code>netplan apply</code> 使之生效</p>
<figure class="highlight yaml"><table><tbody><tr><td class="code"><pre><span class="line"><span class="attr">ethernets:</span></span><br><span class="line">    <span class="attr">wan1:</span></span><br><span class="line">      <span class="attr">match:</span>         <span class="comment"># 根据mac地址匹配，将配置参数应用到匹配的网卡上</span></span><br><span class="line">        <span class="attr">macaddress:</span> <span class="string">XX:XX:XX:XX:XX:01</span></span><br><span class="line">      <span class="attr">set-name:</span> <span class="string">wan1</span> <span class="comment"># 提高可读性，将网卡重命名为 wan1</span></span><br><span class="line">      <span class="comment"># dhcp4: true  # 动态IP,启用时需删除addresses,gateway4,nameservers</span></span><br><span class="line">      <span class="attr">addresses:</span>     <span class="comment"># 静态IP,据上级路由器而定，启用时关闭动态IP</span></span><br><span class="line">        <span class="bullet">-</span> <span class="number">192.168</span><span class="number">.1</span><span class="number">.11</span><span class="string">/24</span></span><br><span class="line">      <span class="attr">gateway4:</span> <span class="number">192.168</span><span class="number">.1</span><span class="number">.1</span> <span class="comment"># 设置静态IP时需要</span></span><br><span class="line">      <span class="attr">nameservers:</span>          <span class="comment"># 设置静态IP时需要</span></span><br><span class="line">        <span class="attr">addresses:</span></span><br><span class="line">          <span class="bullet">-</span> <span class="number">192.168</span><span class="number">.1</span><span class="number">.1</span></span><br><span class="line">    <span class="attr">eth1:</span></span><br><span class="line">      <span class="attr">match:</span></span><br><span class="line">        <span class="attr">macaddress:</span> <span class="string">XX:XX:XX:XX:XX:02</span></span><br><span class="line">      <span class="attr">set-name:</span> <span class="string">eth1</span></span><br><span class="line">      <span class="attr">dhcp4:</span> <span class="literal">no</span></span><br><span class="line">    <span class="attr">eth2:</span></span><br><span class="line">      <span class="attr">match:</span></span><br><span class="line">        <span class="attr">macaddress:</span> <span class="string">XX:XX:XX:XX:XX:03</span></span><br><span class="line">      <span class="attr">set-name:</span> <span class="string">eth2</span></span><br><span class="line">      <span class="attr">dhcp4:</span> <span class="literal">no</span></span><br></pre></td></tr></tbody></table></figure>

<h3 id="开启端口转发功能"><a href="#开启端口转发功能" class="headerlink" title="开启端口转发功能"></a>开启端口转发功能</h3><p>ubuntu 默认的未开启端口转发功能，需要手动开启，<br>打开 <code>/etc/sysctl.conf</code> 并设置如下字段：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">net.ipv4.ip forward=1</span><br></pre></td></tr></tbody></table></figure>

<p>还需要在 iptables 设置 nat 表的转发 (重启之后会失效，还需要持久化配置)</p>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">sudo iptables -t nat -A POSTROUTING -o wan1 -j MASQUERADE</span><br></pre></td></tr></tbody></table></figure>

<h3 id="持久化iptables的配置"><a href="#持久化iptables的配置" class="headerlink" title="持久化iptables的配置"></a>持久化 iptables 的配置</h3><p>ubuntu20 中使用 systemd 来管理开机任务<br>这里创建一个 service，作用是在开机时加载 iptables 规则，在关机时保存 iptables 规则</p>
<ul>
<li>service 文件路径  <code>/etc/systemd/system/myiptables.service</code></li>
<li>处理 iptables 的脚本路径  <code>/home/root/iptable.bash</code></li>
<li>iptables 备份文件保存路径  <code>/home/root/backup.iptable.ipv4</code></li>
</ul>
<p>创建文件 service 文件，内容如下</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">[Unit]</span><br><span class="line">Description=backup iptables when shutdown &amp; restore iptables when boot</span><br><span class="line">After=chinadns-ng.service</span><br><span class="line">After=myipset.service</span><br><span class="line"></span><br><span class="line">[Service]</span><br><span class="line">Type=oneshot</span><br><span class="line">RemainAfterExit=true</span><br><span class="line">ExecStart=/bin/bash /home/root/iptable.bash restore # 开机时执行的命令</span><br><span class="line">ExecStop=/bin/bash /home/root/iptable.bash backup   # 关机时执行的命令</span><br><span class="line"></span><br><span class="line">[Install]</span><br><span class="line">WantedBy=multi-user.target</span><br></pre></td></tr></tbody></table></figure>

<p>上面用到的保存 iptables 数据的脚本  <code>iptable.bash</code> 内容如下，</p>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line">default_backup_file=<span class="string">"/home/root/backup.iptable.ipv4"</span></span><br><span class="line"></span><br><span class="line">action=<span class="variable">$1</span></span><br><span class="line">backup_file=<span class="variable">${2:-<span class="variable">$default_backup_file</span>}</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> [[ <span class="string">"<span class="variable">$action</span>"</span> == <span class="string">'restore'</span> ]]; <span class="keyword">then</span></span><br><span class="line">  /sbin/iptables-restore &lt;<span class="string">"<span class="variable">${backup_file}</span>"</span></span><br><span class="line">  <span class="built_in">exit</span> 0</span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"><span class="keyword">if</span> [[ <span class="string">"<span class="variable">$action</span>"</span> == <span class="string">'backup'</span> ]]; <span class="keyword">then</span></span><br><span class="line">  ensure_dir_exist <span class="string">"<span class="subst">$(dirname <span class="string">"<span class="variable">$backup_file</span>"</span>)</span>"</span></span><br><span class="line">  /sbin/iptables-save &gt;<span class="string">"<span class="variable">${backup_file}</span>"</span></span><br><span class="line">  <span class="built_in">exit</span> 0</span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> iptables backup_file path: <span class="string">"<span class="variable">${default_backup_file}</span>"</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"user param: 'backup' or 'restore'"</span></span><br><span class="line"><span class="built_in">exit</span> 1</span><br></pre></td></tr></tbody></table></figure>

<p>保存好脚本<br>之后手动保存一次 iptables 的数据： <code>iptables-save &gt; /home/root/backup.iptable.ipv4</code><br>接下来开始激活 myiptables.service：</p>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">sudo systemctl daemon-reload <span class="comment"># systemd刷新service文件</span></span><br><span class="line">sudo systemctl <span class="built_in">enable</span> myiptables <span class="comment"># 启用开机自启动 myiptables</span></span><br><span class="line">sudo systemctl start myiptables <span class="comment"># 运行 myiptables</span></span><br></pre></td></tr></tbody></table></figure>

<p>至此 iptables 数据能够实现开机不丢失。</p>
<h3 id="配置网桥"><a href="#配置网桥" class="headerlink" title="配置网桥"></a>配置网桥</h3><p>目的是让 lan 口的多个设备之间可以通信<br>编辑 netplan 的配置文件: <code>/etc/netplan/00-installer-config.yaml</code><br>在  <code>ethernets</code> 同级别增加字段  <code>bridges</code>，之后重启 netplan</p>
<figure class="highlight yaml"><table><tbody><tr><td class="code"><pre><span class="line"><span class="attr">bridges:</span></span><br><span class="line">  <span class="attr">br:</span></span><br><span class="line">    <span class="attr">interfaces:</span> <span class="comment"># 网桥上要包含的端口</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">eth1</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">eth2</span></span><br><span class="line">    <span class="attr">addresses:</span>  <span class="comment"># 网桥的地址</span></span><br><span class="line">      <span class="bullet">-</span> <span class="number">10.10</span><span class="number">.20</span><span class="number">.1</span><span class="string">/24</span></span><br><span class="line">    <span class="attr">dhcp4:</span> <span class="literal">no</span></span><br></pre></td></tr></tbody></table></figure>

<h3 id="dnsmasq-配置DHCP和DNS服务"><a href="#dnsmasq-配置DHCP和DNS服务" class="headerlink" title="dnsmasq: 配置DHCP和DNS服务"></a>dnsmasq: 配置 DHCP 和 DNS 服务</h3><p>安装域名服务 <code>dnsmasq</code>: <code>apt-get install dnsmasq</code></p>
<p>修改 <code>/etc/dnsmasq.conf</code> 修改字段为以下配置</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">listen-address=127.0.0.1,10.10.20.1 # 监听 127.0.0.1 和 网桥的地址</span><br><span class="line">port=53                             # DNS 服务端口</span><br><span class="line">interface=eth1                      # DNS &amp; DHCP 服务网卡</span><br><span class="line">interface=eth2                      # DNS &amp; DHCP 服务网卡</span><br><span class="line"></span><br><span class="line">dhcp-range=10.10.20.10,10.10.20.99,255.255.255.0,12h  # DHCP 的IP范围,子网掩码,租期</span><br><span class="line">dhcp-option=option:router,10.10.20.1                  # 网关地址（网桥）</span><br><span class="line">dhcp-option=option:dns-server,10.10.20.1              # DNS 地址</span><br></pre></td></tr></tbody></table></figure>

<p>之后重启 dnsmasq: <code>systemctl restart dnsmasq.service</code>。</p>
<p>如果因为 53 端口被占用启动失败，需要先停止 systemd-resolved 服务：</p>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">sudo systemctl stop systemd-resolved      <span class="comment"># 关闭服务，但是开机还会自启动</span></span><br><span class="line">sudo systemctl <span class="built_in">disable</span> systemd-resolved   <span class="comment"># 开机不再自启动</span></span><br></pre></td></tr></tbody></table></figure>

<p>至此路由器即可正常工作。</p>
]]></content>
      <categories>
        <category>Linux</category>
        <category>Router</category>
      </categories>
      <tags>
        <tag>Router(软路由)</tag>
      </tags>
  </entry>
  <entry>
    <title>Ubuntu 下添加新硬盘操作</title>
    <url>/posts/a702/</url>
    <content><![CDATA[<p>最近在安装 ESXI 环境，记录一下在 ubuntu 添加新硬盘的步骤，从中可以窥见 Ubuntu 对硬盘设备的管理裸机。</p>
<span id="more"></span>

<hr>
<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><ul>
<li>下文操作环境是 ESXI 上的虚拟机，理论上对物理机同样适用</li>
<li>文中内容包括<ul>
<li>对硬盘建分区</li>
<li>格式化分区</li>
<li>将硬盘挂载到一个已经存在的目录</li>
<li>设置开机自动挂载</li>
</ul>
</li>
</ul>
<h2 id="添加硬盘"><a href="#添加硬盘" class="headerlink" title="添加硬盘"></a>添加硬盘</h2><p>在 esxi 的虚拟机管理页时，在第一行可以为虚拟机添加额外的硬盘，网卡等设备。</p>
<p><img src="https://storage.googleapis.com/ppzz_blog/18/1.png" alt="1" title="ESXI 虚拟机管理页面截图，第三行小字有Label可以添加硬盘"></p>
<p>增加硬盘后开机，硬盘连接到了 ubunut 系统，但是并没有做任何初始化工作，此时需要：</p>
<ol>
<li>新建分区</li>
<li>格式化分区</li>
<li>将硬盘挂载到一个已经存在的目录</li>
<li>设置开机自动挂载</li>
</ol>
<p>之后才能够无感的使用。</p>
<h2 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h2><h3 id="查看硬盘信息"><a href="#查看硬盘信息" class="headerlink" title="查看硬盘信息"></a>查看硬盘信息</h3><p>用这个命令：</p>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">sudo fdisk -l</span><br></pre></td></tr></tbody></table></figure>

<p>截图如下：</p>
<p><img src="https://storage.googleapis.com/ppzz_blog/18/2.png" alt="2" title="ESXI 虚拟机管理页面截图，第三行小字有Label可以添加硬盘"></p>
<p>实际输出：</p>
<blockquote>
<p>Disk /dev/sda: 30 GiB, 32212254720 bytes, 62914560 sectors<br>Disk model: Virtual disk<br>Units: sectors of 1 * 512 = 512 bytes<br>Sector size (logical/physical): 512 bytes / 512 bytes<br>I/O size (minimum/optimal): 512 bytes / 512 bytes<br>Disklabel type: gpt<br>Disk identifier: 3C1AD3FC-FCB4-42DE-8AEB-266F62F453C9</p>
<p>Device       Start      End  Sectors Size Type<br>/dev/sda1     2048     4095     2048   1M BIOS boot<br>/dev/sda2     4096  2101247  2097152   1G Linux filesystem<br>/dev/sda3  2101248 62912511 60811264  29G Linux filesystem</p>
<p>Disk /dev/sdb: 100 GiB, 107374182400 bytes, 209715200 sectors<br>Disk model: Virtual disk<br>Units: sectors of 1 * 512 = 512 bytes<br>Sector size (logical/physical): 512 bytes / 512 bytes<br>I/O size (minimum/optimal): 512 bytes / 512 bytes</p>
</blockquote>
<p>解读：</p>
<p>其中 sda 是已经在使用中的硬盘，包括三个分区: sda1, sda2, sda3</p>
<p>而 sdb 还没有分区存在。</p>
<h3 id="新建分区"><a href="#新建分区" class="headerlink" title="新建分区"></a>新建分区</h3><p>使用这个命令对硬盘进行分区：</p>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">sudo fdisk /dev/sdb</span><br></pre></td></tr></tbody></table></figure>

<p>截图如下</p>
<p><img src="https://storage.googleapis.com/ppzz_blog/18/3.png" alt="3" title="ESXI 虚拟机管理页面截图，第三行小字有Label可以添加硬盘"></p>
<p>实际输出</p>
<blockquote>
<p>hardnuts@vlab7:/mnt/volume$ sudo fdisk /dev/sdb</p>
<p>Welcome to fdisk (util-linux 2.34).<br>Changes will remain in memory only, until you decide to write them.<br>Be careful before using the write command.</p>
<p>Device does not contain a recognized partition table.<br>Created a new DOS disklabel with disk identifier 0x4cf6e589.</p>
<p>Command (m for help): m</p>
</blockquote>
<p>根据提示，依次执行以下命令:</p>
<ul>
<li>n (新建分区)</li>
<li>p (打印详情)</li>
<li>w (写入磁盘)</li>
<li>q (退出)</li>
</ul>
<p>截图:</p>
<p><img src="https://storage.googleapis.com/ppzz_blog/18/4.png" alt="4" title="ESXI 虚拟机管理页面截图，第三行小字有Label可以添加硬盘"></p>
<p>输出如下:</p>
<blockquote>
<p>Command (m for help): n<br>Partition type<br>    p   primary (0 primary, 0 extended, 4 free)<br>    e   extended (container for logical partitions)<br>Select (default p): p<br>Partition number (1-4, default 1):<br>First sector (2048-209715199, default 2048):<br>Last sector, +/-sectors or +/-size{K,M,G,T,P} (2048-209715199, default 209715199):</p>
<p>Created a new partition 1 of type ‘Linux’ and of size 100 GiB.</p>
<p>Command (m for help): p<br>Disk /dev/sdb: 100 GiB, 107374182400 bytes, 209715200 sectors<br>Disk model: Virtual disk<br>Units: sectors of 1 * 512 = 512 bytes<br>Sector size (logical/physical): 512 bytes / 512 bytes<br>I/O size (minimum/optimal): 512 bytes / 512 bytes<br>Disklabel type: dos<br>Disk identifier: 0x287febb1</p>
<p>Device     Boot Start       End   Sectors  Size Id Type<br>/dev/sdb1        2048 209715199 209713152  100G 83 Linux</p>
<p>Command (m for help): w<br>The partition table has been altered.<br>Calling ioctl() to re-read partition table.<br>Syncing disks.</p>
</blockquote>
<p>再查看看硬盘信息：</p>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">sudo fdisk -l</span><br></pre></td></tr></tbody></table></figure>

<p>可以看见已经存在分区了：</p>
<p><img src="https://storage.googleapis.com/ppzz_blog/18/5.png" alt="5" title="ESXI 虚拟机管理页面截图，第三行小字有Label可以添加硬盘"></p>
<p>输出：</p>
<blockquote>
<p>Disk /dev/sdb: 100 GiB, 107374182400 bytes, 209715200 sectors<br>Disk model: Virtual disk<br>Units: sectors of 1 * 512 = 512 bytes<br>Sector size (logical/physical): 512 bytes / 512 bytes<br>I/O size (minimum/optimal): 512 bytes / 512 bytes<br>Disklabel type: dos<br>Disk identifier: 0x287febb1</p>
<p>Device     Boot Start       End   Sectors  Size Id Type<br>/dev/sdb1        2048 209715199 209713152  100G 83 Linux</p>
</blockquote>
<p>但是这个时候分区还不能够使用，需要格式化之后才能够正常使用。</p>
<h3 id="格式化和挂载分区"><a href="#格式化和挂载分区" class="headerlink" title="格式化和挂载分区"></a>格式化和挂载分区</h3><p>格式化命令</p>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">sudo mkfs -t ext4 /dev/sdb1</span><br></pre></td></tr></tbody></table></figure>

<p>挂载分区即可使用</p>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">sudo mount -t auto /dev/sdb1 /mnt/volume</span><br></pre></td></tr></tbody></table></figure>

<p>挂载的分区重启之后会消失掉。需要在每次开机之后再手动执行挂载命令。<br>当然应该做成自动挂载。</p>
<h3 id="开机自动挂载"><a href="#开机自动挂载" class="headerlink" title="开机自动挂载"></a>开机自动挂载</h3><p>这里使用硬盘分区的 uuid 来定位一个分区，</p>
<p>查看磁盘的 UUID</p>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">blkid /dev/sdb1</span><br></pre></td></tr></tbody></table></figure>

<p>输出：</p>
<blockquote>
<p>/dev/sdb1: UUID=”c41fa94b-7789-4f22-bb69-3a7f7c924147” TYPE=”ext4” PARTUUID=”287febb1-01”</p>
</blockquote>
<p>我们需要记录下来 UUID 这部分：“c41fa94b-7789-4f22-bb69-3a7f7c924147”</p>
<p>另一种查看 uuid 的方式是这样：</p>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> /dev/disk/by-uuid</span><br><span class="line">ls -l </span><br></pre></td></tr></tbody></table></figure>

<p>可以看到有多个 uuid 以及其连接的分区，其中也可以找到 sdb1 这个分区的 UUID。</p>
<p>接下来编辑 fstab</p>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">sudo vim /etc/fstab</span><br></pre></td></tr></tbody></table></figure>

<p>加入以下行：（其中用到了 sdb1 的 UUID）</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">/dev/disk/by-uuid/c41fa94b-7789-4f22-bb69-3a7f7c924147 /mnt/volume  ext4 defaults 0 0</span><br></pre></td></tr></tbody></table></figure>

<p>其中：</p>
<ul>
<li>/dev/disk/by-uuid/c41fa94b-7789-4f22-bb69-3a7f7c924147 是磁盘的定位符</li>
<li> /mnt/volume 挂载点</li>
<li> ext4 文件系统类型</li>
<li> defaults 挂载选项</li>
<li> 0 dump 选项：是否让备份程序 dump 备份文件系统，0 为忽略，1 为备份，如果上次用 dump 备份，将显示备份至今的天数。</li>
<li>0 fsck 选项：fsck 程序以什么顺序检查文件系统，为 0 就表示不检查，（/）分区永远都是 1，其它的分区只能从 2 开始，当数字相同就同时检查（但不能有两 1）</li>
</ul>
<p>之后重启系统就可以自动挂载分区了。</p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Git: 基础原理</title>
    <url>/posts/1690/</url>
    <content><![CDATA[<p>Git 的基本原理和使用。</p>
<span id="more"></span>

<h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p>工作区（工作目录）：git 将一个目录作为工作目录，目录中文件的不断的变化，Git 不断的追踪这些文件的变化。</p>
<p>在这个过程中 git 将文件的状态大致可以分成了 5 种：</p>
<ul>
<li>none      (表示文件还不存在)</li>
<li>untracked（文件存在，但是没有被 git 管理）</li>
<li>modified （文件被修改，其前置状态是 staged 或者 commited）</li>
<li>staged   （文件被 git 暂是记录下来）</li>
<li>committed（文件被保存到 git 仓库）</li>
</ul>
<p>文件变动的过程中，git 会记录这些文件每个状态的样子。有点费解可以参考下面关于 staged 状态变为 modified 状态的情况。<br>一个文件经历过这些变化才会被 git 真正的记录下来，明白这些变化的过程，就可以明白 git 具体做了什么事情。事实上绝大部分的 git 命令都是在使文件在这些状态之间切换。</p>
<h3 id="文件被提交的过程"><a href="#文件被提交的过程" class="headerlink" title="文件被提交的过程"></a>文件被提交的过程</h3><p>图里列举了两个典型的案例：</p>
<ul>
<li>绿色部分代表一个新文件被提交的过程</li>
<li>黄色部分代表一个文件被改动后之后再被提交的过程 </li>
</ul>
<pre class="mermaid">sequenceDiagram
    participant none      as none
    participant untracked as untracked
    participant modified  as modified 
    participant staged    as staged
    participant committed as committed

    rect rgb(123, 237, 159)
    none      -&gt;&gt; untracked: 新创建文件
    untracked -&gt;&gt; staged: git add 
    staged    -&gt;&gt; committed: git commit
    end

    rect rgb(236, 204, 104)
    committed -&gt;&gt; modified: 修改文件
    modified  -&gt;&gt; staged: git add
    staged    -&gt;&gt; modified: 修改文件
    end

%%</pre>

<p>先来看看一个新文件的状态是怎么变化的：</p>
<ul>
<li>文件默认不存在，可以认为这个文件的状态是 none，当文件被创建，git 就认为它是 untracked 状态。</li>
<li>git add 命令将 untracked 状态变为 staged 的状态，之后便可以被 git 追踪到 该文件的变化。</li>
<li>git commit 命令 staged 状态变为 committed 状态，这个动作会让 git 保存文件 staged 状态下的快照。每一次快照会有一个 commitID 作为唯一标识被固定下来。</li>
</ul>
<p>再来看看一次对已有文件的改动有哪些状态变化：</p>
<ul>
<li>committed 状态的文件被改动后 会被标记成 modified</li>
<li>modified 通过 git add 命令 会被标记成 staged 状态，之后可以被 git commit 命令记录下来。</li>
<li>图中的虚线表示在 staged 状态修改文件之后，文件会被叫标记成 modified 状态，这时候，git 同时记录了这两种状态的文件版本；此时在 modified 状态执行 git commit 命令实际记录的是 staged 状态的文件内容。</li>
</ul>
<h3 id="撤销修改时的状态变化过程"><a href="#撤销修改时的状态变化过程" class="headerlink" title="撤销修改时的状态变化过程"></a>撤销修改时的状态变化过程</h3><p>git 好用的地方在于提供了足够多的回退方法。文件几乎可以在各个状态间回退而不丢失修改的内容，从而撤销内容或者提交。</p>
<p>自己整理的一些状态流转过程：</p>
<pre class="mermaid">sequenceDiagram
    participant untracked as untracked
    participant modified  as modified 
    participant staged    as staged
    participant committed as committed

    rect rgb(255, 127, 80)
        committed -&gt;&gt; staged: git reset --soft 
        committed -&gt;&gt; modified: git reset
        committed -&gt;&gt; untracked: git rm --cached
        staged    -&gt;&gt; modified: git reset
        modified  -&gt;&gt; committed: git checkout(回到上次提交，丢弃改动)
    end
%%</pre>

<ul>
<li>以上的过程除个别标注外，不会丢失代码的改动。其改动的仅是 git 记录的版本信息，代码的工作量不会丢失。</li>
<li>慎用各种回退命令，不同的状态下使用可能会丢失对代码的修改。</li>
</ul>
<h2 id="一些资料"><a href="#一些资料" class="headerlink" title="一些资料"></a>一些资料</h2><ul>
<li><a href="https://git-scm.com/book/zh/v2">Pro Git</a>: 权威的开源书籍，已经有中文译本了。稍微有点枯燥，作为手册来说很好用。</li>
<li><a href="https://marklodato.github.io/visual-git-guide/index-zh-cn.html#diff">图解 Git</a>: github 一个开源库，详细讲了 git 的 commit 之间的变换原理。</li>
</ul>
]]></content>
      <categories>
        <category>Git</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title>Gmail 的过滤技巧</title>
    <url>/posts/c324/</url>
    <content><![CDATA[<p>Gmail 的邮件过滤技巧。</p>
<span id="more"></span>

<ul>
<li>from 发件人<ul>
<li> from:amy OR from:david</li>
</ul>
</li>
<li>to 收件人</li>
<li> subject 主题</li>
<li> or | {}<ul>
<li>from:amy OR from:david</li>
<li>{from:amy from:david}</li>
</ul>
</li>
<li><ul>
<li> 从结果中排除邮件</li>
</ul>
<ul>
<li> dinner -movie</li>
</ul>
</li>
<li>AROUND 时间范围<ul>
<li> dinner around 5 friday 前后 5 天</li>
</ul>
</li>
<li> Label （标记）<ul>
<li>Label:important</li>
<li>social | updates | forums | promotions | invoice</li>
</ul>
</li>
<li>Has 具有某个特征<ul>
<li> Has:attachment</li>
<li>Has:drive | document | spreadsheet | presentation | youtube</li>
<li>Has: yellow-star | blue-info | purple-star</li>
<li>has:nouserlabels</li>
<li>has:userlabels</li>
</ul>
</li>
<li>List<ul>
<li>list:<a href="mailto:info@example.com">info@example.com</a></li>
</ul>
</li>
<li>Filename 文件名<ul>
<li> Filename:pdf</li>
</ul>
</li>
<li>“”<ul>
<li>“dinner and movie tonight”</li>
</ul>
</li>
<li>()<ul>
<li>subject:(dinner movie)</li>
</ul>
</li>
<li>In <ul>
<li>In:anywhere  — 包括垃圾邮件和已删除邮件</li>
</ul>
</li>
<li> is<ul>
<li>Is: important | starred | snoozed | unread | read</li>
<li>is:chat</li>
</ul>
</li>
<li>Cc<ul>
<li>Cc:david</li>
</ul>
</li>
<li>Bcc</li>
<li>After | before | older| newer<ul>
<li>after:2004/04/16</li>
</ul>
</li>
<li>older_than | newer_than<ul>
<li>newer_than:2d</li>
</ul>
</li>
<li>deliveredto</li>
<li>category<ul>
<li>category:updates</li>
</ul>
</li>
<li>size<ul>
<li>size:1000000</li>
</ul>
</li>
<li>larger | smaller<ul>
<li>larger:10M</li>
</ul>
</li>
<li><ul>
<li> 完全匹配</li>
</ul>
<ul>
<li> +unicorn. - 完全匹配某字</li>
</ul>
</li>
<li> label</li>
<li>Is<ul>
<li>Unread</li>
<li>Archieve</li>
</ul>
</li>
<li>In<ul>
<li>Starred</li>
<li>Drafts</li>
<li>Chat</li>
</ul>
</li>
<li>From<ul>
<li> 发件人</li>
<li> from:Boss_Name subject:(Urgent OR Important)</li>
</ul>
</li>
<li>to<ul>
<li> 收件邮箱</li>
</ul>
</li>
<li> filename<ul>
<li> 附件的种类</li>
<li> filename:.zip before:2007/08/15 wordpress</li>
</ul>
</li>
<li>before|after<ul>
<li> 某段时间之前 | 之后，格式 YYYY/MM/DD</li>
</ul>
</li>
<li> 其它<ul>
<li> has:attachment</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>Gmail</category>
      </categories>
      <tags>
        <tag>Gmail</tag>
      </tags>
  </entry>
  <entry>
    <title>VirtualBox 网络配置</title>
    <url>/posts/8f27/</url>
    <content><![CDATA[<p>之前对 VirtualBox 各个网络模型的区别有点模糊，今天整理了一下，记下来备查。</p>
<span id="more"></span>

<h2 id="连通性表"><a href="#连通性表" class="headerlink" title="连通性表"></a>连通性表</h2><p>区分 virtualbox 的网络: nat、nat network、bridge，一图胜千言：</p>
<table>
<thead>
<tr>
<th align="center"></th>
<th>NAT</th>
<th>NAT network</th>
<th>Bridge</th>
<th>Internal</th>
<th>Host only</th>
</tr>
</thead>
<tbody><tr>
<td align="center">guest -&gt; host</td>
<td>yes</td>
<td>yes</td>
<td>yes</td>
<td>no</td>
<td>yes</td>
</tr>
<tr>
<td align="center">host -&gt; guest</td>
<td> 端口转发</td>
<td>端口转发</td>
<td> yes</td>
<td>no</td>
<td>yes</td>
</tr>
<tr>
<td align="center">guest -&gt; other</td>
<td>yes</td>
<td>yes</td>
<td>yes</td>
<td>no</td>
<td> 共享或桥接</td>
</tr>
<tr>
<td align="center"> other -&gt; guest</td>
<td> 端口转发</td>
<td>端口转发</td>
<td> yes</td>
<td>no</td>
<td> 桥接</td>
</tr>
<tr>
<td align="center"> guest -&gt; guest</td>
<td>no</td>
<td>yes</td>
<td>yes</td>
<td> 同网络</td>
<td> yes</td>
</tr>
</tbody></table>
<ul>
<li>host 是我的主机</li>
<li> guest 是 VirtualBox 中的虚拟机</li>
<li>第一列表示各个主机之间的通信关系；第一行表示各个网络拓扑下的网络连通性。</li>
</ul>
<h2 id="每种网络模式特点的说明"><a href="#每种网络模式特点的说明" class="headerlink" title="每种网络模式特点的说明"></a>每种网络模式特点的说明</h2><ul>
<li>NAT<ul>
<li> 虚拟机 IP 地址从 virtualBox 自带的 DHCP 服务器上获取，更改 IP 参考 virtualbox <a href="ttps://www.virtualbox.org/manual/ch09.html#changenat">文档</a></li>
</ul>
</li>
<li> NAT network<ul>
<li> 需要在 virtualBox 中添加一个网络（最好重启一次 virtualBox，出现了修改了网络之后，重启虚拟机，但是 virtualBox 的 nat 网络配置不变的情况）</li>
</ul>
</li>
<li>Bridge<ul>
<li> 需要在 HOST 上配置（网络共享之类的操作）</li>
<li>虚拟机 IP 地址需要和 HOST 在同一网段</li>
</ul>
</li>
<li> Host network<ul>
<li>host 上会有一个 network interface 被创建出来：vboxnet0，主机会有自己的 ip 地址</li>
<li>当两个虚拟机的 ip 相同时，主机使用 IP 连接的时最后一次跟主机通信的 mac 地址对应的机器。</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>Network</category>
      </categories>
      <tags>
        <tag>网络基础</tag>
        <tag>virtualBox</tag>
      </tags>
  </entry>
  <entry>
    <title>Macbook 设置备忘</title>
    <url>/posts/80a8/</url>
    <content><![CDATA[<p>我在 MAC 上的常用命令、软件和技巧。</p>
<span id="more"></span>

<h3 id="常用的命令"><a href="#常用的命令" class="headerlink" title="常用的命令"></a>常用的命令</h3><figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment"># 计算Md5值</span></span><br><span class="line">md5 aaa.file</span><br><span class="line"></span><br><span class="line"><span class="comment"># Base64</span></span><br><span class="line">base64 -i a.iso -o a.iso.ba64       <span class="comment"># 编码文件</span></span><br><span class="line">base64 -D -i a.iso -o a.iso.ba64    <span class="comment"># 解码文件</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 系统信息</span></span><br><span class="line">networksetup -listallhardwareports  <span class="comment"># 查看网络设备</span></span><br><span class="line">sysctl -n machdep | grep CPU        <span class="comment"># 查看CPU型号</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 文件转码</span></span><br><span class="line">iconv -c -f GB2312 -t UTF-8 some.file &gt;&gt; new.file</span><br><span class="line"></span><br><span class="line"><span class="comment"># 打开文件</span></span><br><span class="line">open -a TextEdit some_file          <span class="comment"># 指定软件打开</span></span><br><span class="line">open -e some_file                   <span class="comment"># 文本编辑器打开</span></span><br><span class="line">open -t somefile                    <span class="comment"># 默认软件打开</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 代理</span></span><br><span class="line"><span class="built_in">export</span> ALL_PROXY=<span class="string">"socks5://127.0.0.1:1080"</span>  <span class="comment"># 同时设置HTTP,HTTPS</span></span><br><span class="line"><span class="built_in">export</span> http_proxy=<span class="string">"socks5://127.0.0.1:1087"</span> <span class="comment"># part1</span></span><br><span class="line"><span class="built_in">export</span> https_proxy=<span class="variable">$http_proxy</span>              <span class="comment"># part2</span></span><br><span class="line">curl --socks5 10.10.20.1:1080  google.com   <span class="comment"># curl使用代理</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 清空本地DNS缓存，通常用在 dig命令能够获取到IP但是ping命令不可以的情况下</span></span><br><span class="line">sudo killall -HUP mDNSResponder</span><br></pre></td></tr></tbody></table></figure>

<h3 id="常用的软件列表"><a href="#常用的软件列表" class="headerlink" title="常用的软件列表"></a>常用的软件列表</h3><ul>
<li>brew formulae 安装<ul>
<li>语言支持: nvm (nodejs), python3, golang</li>
<li>tree: 命令行工具，打印目录结构</li>
<li> ccat: 待语法解析的 cat 命令</li>
<li> proxychains: 命令行代理: <a href="https://github.com/rofl0r/proxychains-ng">github 仓库</a></li>
<li> ext4fuse: 读取 ext4 文件系统</li>
</ul>
</li>
<li> brew casks 安装<ul>
<li>代理工具: proxifier, shadowsocksx-ng-r</li>
<li> 编辑器: visual-studio-code, typora, hex-fiend (编辑二进制数据)</li>
<li>omni: omnifocus, omnigraffle</li>
<li> 开发工具: iterm2, jetbrains-toolbox (webstorm, goland)</li>
<li> 多媒体文件: iina (视频播放), pdf-expert, xld (音频转码), the-unarchiver (解压)</li>
<li>eudic: 欧路词典</li>
<li> balenaEtcher: 制作启动盘</li>
<li> dupeguru: 扫描重复文件</li>
<li> cheatsheet: 快捷键提示</li>
<li> keycastr: 在屏幕上展示按键（用于分享会时）</li>
<li>intel-power-gadget: 展示 CPU 的实时信息</li>
</ul>
</li>
<li> appStore 安装<ul>
<li> Magnet: 窗口管理</li>
</ul>
</li>
<li>其他<ul>
<li> xcode-select –install （调试工具）</li>
</ul>
</li>
</ul>
<h3 id="其他技巧"><a href="#其他技巧" class="headerlink" title="其他技巧"></a>其他技巧</h3><p>家庭共享设置过程</p>
<ul>
<li>效果<ul>
<li>在 ios: music/vedio 等 app 上播放 mac 中的音乐 / 视屏 / 照片 / 有声书 / 博客等</li>
<li>在 appleTV 上播放上述资料</li>
</ul>
</li>
<li>要求：ios/appleTV 设备上，在对应的 app 的设置里，需要和 mac 使用同一个 appleID</li>
<li> 步骤 mac：<ul>
<li>打开 Itunes，登陆 appleID</li>
<li>Itunes 设置–sharing–勾选 “在本地网络分享资料库”</li>
<li>Itunes 菜单–home sharing–turn on</li>
</ul>
</li>
<li> 步骤 ios：<ul>
<li>设置–music–家庭共享–账号（视频类似）</li>
<li>在 music 中即可播放</li>
</ul>
</li>
<li>步骤 appleTV：<ul>
<li>设置–账号–家庭共享–账号登录</li>
<li>在 “电脑” app 中播放 2</li>
</ul>
</li>
</ul>
<h3 id="brew-配置国内的软件园"><a href="#brew-配置国内的软件园" class="headerlink" title="brew 配置国内的软件园"></a>brew 配置国内的软件园</h3><p>homebrew  需要替换四个软件源</p>
<ol>
<li>Homebrew</li>
<li>Homebrew Core</li>
<li>Homebrew-bottles</li>
<li>Homebrew Cask</li>
</ol>
<p>一下使用中科大源：</p>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment"># 替换 Homebrew</span></span><br><span class="line">git -C <span class="string">"<span class="subst">$(brew --repo)</span>"</span> remote set-url origin https://mirrors.ustc.edu.cn/brew.git</span><br><span class="line"></span><br><span class="line"><span class="comment"># 替换 Homebrew Core</span></span><br><span class="line">git -C <span class="string">"<span class="subst">$(brew --repo homebrew/core)</span>"</span> remote set-url origin https://mirrors.ustc.edu.cn/homebrew-core.git</span><br><span class="line"></span><br><span class="line"><span class="comment"># 替换 Homebrew Cask</span></span><br><span class="line">git -C <span class="string">"<span class="subst">$(brew --repo homebrew/cask)</span>"</span> remote set-url origin https://mirrors.ustc.edu.cn/homebrew-cask.git</span><br><span class="line"></span><br><span class="line"><span class="comment"># Homebrew-bottles, 在 .bashrc中设置：</span></span><br><span class="line"><span class="built_in">export</span> HOMEBREW_BOTTLE_DOMAIN=https://mirrors.ustc.edu.cn/homebrew-bottles</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>

]]></content>
      <categories>
        <category>Mac</category>
      </categories>
      <tags>
        <tag>Mac</tag>
      </tags>
  </entry>
  <entry>
    <title>Git: 好用到爆命令和配置</title>
    <url>/posts/beaa/</url>
    <content><![CDATA[<p>让 Git 的更好用的配置和命令。</p>
<span id="more"></span>

<h3 id="别名配置"><a href="#别名配置" class="headerlink" title="别名配置"></a>别名配置</h3><p>git 的配置文件通常是 home 目录下的 <code>.gitignore</code></p>
<p>可以追加以下内容:</p>
<figure class="highlight toml"><table><tbody><tr><td class="code"><pre><span class="line"><span class="section">[color]</span></span><br><span class="line">    <span class="attr">ui</span> = <span class="literal">true</span>   <span class="comment"># 启用git输出的颜色控制功能</span></span><br><span class="line"><span class="section">[alias]</span></span><br><span class="line">    <span class="attr">st</span> = status</span><br><span class="line">    <span class="attr">co</span> = checkout</span><br><span class="line">    <span class="attr">ci</span> = commit</span><br><span class="line">    <span class="attr">br</span> = branch</span><br><span class="line">    <span class="attr">di</span> = diff</span><br><span class="line">    <span class="attr">cane</span> = commit --amend --<span class="literal">no</span>-edit  <span class="comment"># 将staged的改动与上次的commit合并（使用上次的提交信息）</span></span><br><span class="line">    <span class="attr">unstage</span> = reset HEAD</span><br><span class="line">    <span class="attr">last</span> = log -<span class="number">1</span></span><br><span class="line">    <span class="attr">lg</span> = log --color --graph --pretty=format:<span class="string">'%C(red)%h%C(reset)%C(green)(%cr)%C(reset)  %s %C(yellow)%d%C(reset) %C(bold blue)%an%Creset'</span> --abbrev-commit</span><br></pre></td></tr></tbody></table></figure>

<ul>
<li>可实现 <code>git st == git status</code> 这样的效果。</li>
<li>上图中 <code>git lg</code> 可以实现图形化展示 git 提交过程。</li>
</ul>
<h3 id="命令备忘"><a href="#命令备忘" class="headerlink" title="命令备忘"></a>命令备忘</h3><p>push</p>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">git push &lt;remote&gt; &lt;tag&gt;</span><br><span class="line">git push --tag</span><br></pre></td></tr></tbody></table></figure>

<p>tag</p>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">git tag -a 1.0.1 -m ‘fixed bug’ <span class="comment">#添加一个tag</span></span><br><span class="line"></span><br><span class="line">git tag -a 2.0.0 -m ‘msg’ COMMITID <span class="comment">#指定commit号的tag</span></span><br><span class="line"></span><br><span class="line">git tag v0.1.2 <span class="comment">#轻量级的tag</span></span><br></pre></td></tr></tbody></table></figure>

<p>checkout：从远端切分支出来</p>
<figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line">git co -b local_name origin/romote_name</span><br></pre></td></tr></tbody></table></figure>

<p>delete 远端分支、tag</p>
<figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line">git push origin --delete &lt;branchName&gt;</span><br><span class="line">git push origin --delete tag &lt;tagname&gt;</span><br></pre></td></tr></tbody></table></figure>

<p>rebase：压缩几个 commit 到一个 commit</p>
<figure class="highlight sh"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment"># 从 commmit1 之后到 head 压缩到一起</span></span><br><span class="line">git rebase -i commit1</span><br><span class="line">git rebase --<span class="built_in">continue</span></span><br><span class="line">git rebase --edit-todo</span><br><span class="line">git rebase --abort</span><br></pre></td></tr></tbody></table></figure>

<p>压缩 commit 时:<br>在执行的 rebase 的编辑处，<br>应该把不要的 commit 的记录，从 pick 改成 squash<br>然后，squash 的 commit 就会被压缩到它前一个 commit 上 (形成一个新的 commitID)</p>
<h3 id="修正-Github-Contributions中的统计数据"><a href="#修正-Github-Contributions中的统计数据" class="headerlink" title="修正 Github Contributions中的统计数据"></a>修正 Github Contributions 中的统计数据</h3><p>检查 <code>git log</code> 中的用户名 &amp; 密码是否正确，通常统计数据不正确是因为账户中的邮箱，跟提交代码的邮箱不一致导致。<br>修复统计数据的过程实际上就是修改历史提交中邮箱的过程</p>
<p>修复已经提交的 commit：</p>
<ul>
<li>先克隆一个新的仓库</li>
</ul>
<p><code>git clone --bare https://github.com/user/repo.git</code></p>
<ul>
<li>再在仓库中执行下面的脚本 </li>
</ul>
<figure class="highlight sh"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/sh</span></span><br><span class="line">git filter-branch --env-filter <span class="string">'</span></span><br><span class="line"><span class="string">OLD_EMAIL="旧的Email地址"</span></span><br><span class="line"><span class="string">CORRECT_NAME="正确的用户名"</span></span><br><span class="line"><span class="string">CORRECT_EMAIL="正确的邮件地址"</span></span><br><span class="line"><span class="string">if [ "$GIT_COMMITTER_EMAIL" = "$OLD_EMAIL" ]</span></span><br><span class="line"><span class="string">then</span></span><br><span class="line"><span class="string"> export GIT_COMMITTER_NAME="$CORRECT_NAME"</span></span><br><span class="line"><span class="string"> export GIT_COMMITTER_EMAIL="$CORRECT_EMAIL"</span></span><br><span class="line"><span class="string">fi</span></span><br><span class="line"><span class="string">if [ "$GIT_AUTHOR_EMAIL" = "$OLD_EMAIL" ]</span></span><br><span class="line"><span class="string">then</span></span><br><span class="line"><span class="string"> export GIT_AUTHOR_NAME="$CORRECT_NAME"</span></span><br><span class="line"><span class="string"> export GIT_AUTHOR_EMAIL="$CORRECT_EMAIL"</span></span><br><span class="line"><span class="string">fi</span></span><br><span class="line"><span class="string">'</span> --tag-name-filter cat -- --branches --tags</span><br></pre></td></tr></tbody></table></figure>

<ul>
<li>重新推送代码</li>
</ul>
<p><code>git push --force --tags origin 'refs/heads/*'</code></p>
<h3 id="git-diff-输出详解"><a href="#git-diff-输出详解" class="headerlink" title="git diff 输出详解"></a>git diff 输出详解</h3><p>这里的内容以软件 diff 为例，内容是以前在笔记中写的。git diff 与之类似，就不再重写了。</p>
<p>假设有 test1.md, test2.md 两个文本文件.</p>
<p>test1.md</p>
<figure class="highlight md"><table><tbody><tr><td class="code"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">this is line 5 of test1</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">this is line 13 of test1</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>

<p>test2.md</p>
<figure class="highlight md"><table><tbody><tr><td class="code"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">this is line 5 of test2</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">this is line 13 of test2</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td></tr></tbody></table></figure>

<p>两个文件只有第 5 和 13 行是不一样的.<br>我们在终端中执行以下代码即可将两个文件的比较结果写入新的 diff.md 中:</p>
<figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line">diff -u test1.md test2.md &gt; diff.md</span><br></pre></td></tr></tbody></table></figure>

<p>解释:<br><code>-u</code> 是 diff 的参数，表示输出结果时同时输出上下文.<br><code>test1.md</code> <code>test2.md</code> 接下来是参与比较的两个文件<br><code>&gt; diff.md</code> 表示将结果输出到 diff.md 这个文件中 (默认是输出到控制台)<br>以上生成的 diff.md 文件内容是:</p>
<figure class="highlight diff"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">--- test1.md    2015-09-04 19:23:06.708723075 +0800</span></span><br><span class="line"><span class="comment">+++ test2.md    2015-09-04 19:23:36.500721968 +0800</span></span><br><span class="line"><span class="meta">@@ -2,7 +2,7 @@</span></span><br><span class="line"> 2</span><br><span class="line"> 3</span><br><span class="line"> 4</span><br><span class="line"><span class="deletion">-this is line 5 of test1</span></span><br><span class="line"><span class="addition">+this is line 5 of test2</span></span><br><span class="line"> 6</span><br><span class="line"> 7</span><br><span class="line"> 8</span><br><span class="line"><span class="meta">@@ -10,7 +10,7 @@</span></span><br><span class="line"> 10</span><br><span class="line"> 11</span><br><span class="line"> 12</span><br><span class="line"><span class="deletion">-this is line 13 of test1</span></span><br><span class="line"><span class="addition">+this is line 13 of test2</span></span><br><span class="line"> 14</span><br><span class="line"> 15</span><br><span class="line"> 16</span><br></pre></td></tr></tbody></table></figure>

<p>下面是对上面每行的解释:</p>
<ul>
<li>1-2 行：分别记录了 <code>原始文件</code> 和 <code>目标文件</code> 的文件名和时间戳.</li>
<li>3-11 行：以 <code>@@</code> 开头到下一个 <code>@@</code>开头行之前叫做一个差异小节 (表示一处不同).</li>
<li>3 行，12 行：差异定位语句，此行以 <code>@@</code> 开头和结束. <code>-2,7</code> 表示本节包含了原始文件的内容是从第 <code>2</code> 行开始的接下来 <code>7</code> 行. <code>+2,7</code> 则表示目标文件.</li>
<li>4-6 行，9-11 行：以空格开头表示本行的文本在两个文件中是相同的，在这里是作为上下文输出的.</li>
<li>7 行，16 行：以　<code>-</code> 开头表示本行是原始文件的内容．</li>
<li>8 行，17 行：以　<code>+</code> 开头表示本行是原始文件的内容．</li>
<li>在一个差异小节中， <code>-</code> 和 <code>+</code> 开头的行表示了文本的差异．</li>
</ul>
<h3 id="用-patch-来进行-diff-的反向操作"><a href="#用-patch-来进行-diff-的反向操作" class="headerlink" title="用 patch 来进行 diff 的反向操作"></a>用 patch 来进行 diff 的反向操作</h3><p>我们用 <code>diff</code> 生成了 <code>diff.md</code> 文件之后，可以用 <code>patch</code> 进行反向还原.<br>先将 <code>test2.md</code> 文件删除，然后执行以下命令:</p>
<figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line">patch test2.md &lt; diff.md</span><br></pre></td></tr></tbody></table></figure>

<p>然后会根据 <code>test1.md</code> 和 <code>diff.md</code> 生成 <code>test2.md</code> .</p>
<p>当需要利用 <code>test2.md</code> 和 <code>diff.md</code> 生成 <code>test1.md</code> 时，可以执行:</p>
<figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line">patch-R test1.md &lt; diff.md</span><br></pre></td></tr></tbody></table></figure>

<p>这样可以反向生成 <code>test1.md</code></p>
<p>最后，diff 和 patch 还可以用来对目录进行比较，但是他们存在局限性：不能对二进制文件进行比较，Git 中对 对 diff 进行了扩展，支持二进制文件的版本控制和差异比较.</p>
<h3 id="git-hooks"><a href="#git-hooks" class="headerlink" title="git hooks"></a>git hooks</h3><h4 id="client-hook"><a href="#client-hook" class="headerlink" title="client hook"></a>client hook</h4><ul>
<li>提交相关<ol>
<li> pre-commit: 测试代码，style lint，检查 doc，检查文档结果的空白字符是否存在；以非 0 值 exit 出时将放弃提交</li>
<li> prepare-commit-msg: 默认提交信息创建之后，在启动提交信息编辑器运行之前运行；可以看到本次提交的快照信息；可以编辑提交信息模版，合并提交</li>
<li> commit-msg: 接受一个参数：文件路径，存有当前的提交信息，以非 0 值 exit 出时将放弃提交</li>
<li> post-commit: 一般用于通知，可以使用 <code>git log -1 HEAD</code> 获得最后一次提交的信息</li>
</ol>
</li>
<li>电子邮件相关<ol>
<li> applypatch-msg: 接收但个参数，包含请求合并信息的临时文件的名字；如果脚本返回非零值，Git 将放弃该补丁；可以用该脚本来确保提交信息符合格式，或直接用脚本修正格式错误。</li>
<li>pre-applypatch: 运行于应用补丁 之后，产生提交之前，所以你可以用它在提交前检查快照。</li>
<li>post-applypatch: 运行于提交产生之后，可以用它把结果通知给一个小组或所拉取的补丁的作者。</li>
</ol>
</li>
<li>其他<ul>
<li> pre-rebase: 可以使用这个钩子来禁止对已经推送的提交变基</li>
<li> post-rewrite: 被那些会替换提交记录的命令调用 (git commit –amend 和 git rebase)，有一个参数（触发重写的命令名），同时从标准输入中接受一系列重写的提交记录。 这个钩子的用途很大程度上跟 post-checkout 和 post-merge 差不多。</li>
<li>post-checkout: 可以用于可以根据你的项目环境用它调整你的工作目录，放入大的二进制文件、自动生成文档或进行其他类似这样的操作</li>
<li> post-merge: git merge 成功运行后被调用，可以用来验证某些在 Git 控制之外的文件是否存在，这样就能在工作区改变时，把这些文件复制进来</li>
<li> pre-push: 接受远程分支的名字和位置作为参数，同时从标准输入中读取一系列待更新的引用。可以在推送开始之前，用它验证对引用的更新操作</li>
<li> pre-auto-gc: <code>git gc –auto</code> 运行前调用，可以用来设置一些提醒</li>
</ul>
</li>
</ul>
<h4 id="server-hook"><a href="#server-hook" class="headerlink" title="server hook"></a>server hook</h4><p>这些钩子脚本在推送到服务器之前和之后运行。 推送到服务器前运行的钩子可以在任何时候以非零值退出，拒绝推送并给客户端返回错误消息，还可以依你所想设置足够复杂的推送策略。</p>
<ul>
<li>pre-receive: 可以用这个钩子阻止对引用进行非快进（non-fast-forward,git 仓库中已经有一部分代码，所以它不允许你直接把你的代码覆盖上去。）的更新，或者对该推送所修改的所有引用和文件进行访问控制。</li>
<li>update:  pre-receive 脚本十分类似，不同之处在于它会为每一个准备更新的分支各运行一次；推送者同时向多个分支推送内容，pre-receive 只运行一次，相比之下 update 则会为每一个被推送的分支各运行一次。接受三个参数：引用（分支）的名字， 推送前引用指向的 SHA-1 值，用户准备推送的 SHA-1 值。如果 update 脚本以非零值退出，只有相应的那一个引用会被拒绝；其余的依然会被更新。</li>
<li>post-update</li>
<li>post-receive: 在整个过程完结以后运行，可以用来更新其他服务或者用户。接受与 pre-receive 相同的标准输入数据。可以用来通知 CI，更新 Issue 追踪系统，</li>
</ul>
]]></content>
      <categories>
        <category>Git</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title>Git: 如何写好 Commit Message</title>
    <url>/posts/191d/</url>
    <content><![CDATA[<p>更高效的使用 Git Commit Message。</p>
<span id="more"></span>

<h2 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h2><p>个人理解的使用 git 最重要的点是：一定要坚持</p>
<ol>
<li>单一职责提交：一次提交有必要是一个单独的小任务，小到修正一个变量名，只要是一个单独成一个行为的修改，就不应该与其他修改一起提交。</li>
<li>小步提交：随时提交代码，将大的任务拆小，有助于整理思绪，回溯代码。</li>
</ol>
<p>基于这样的原则使用 git，commit message 才能够发挥出应有的作用。试想以下，如果在写了一天的代码，仅仅做了一两次提交，当需要回退到今天某个时候的某一版代码时，岂不是灾难？<br>代码一定会有很多修改或者错误的地方，坚持下来的小步提交让人放心修改，大胆试错。</p>
<h2 id="一个普通的-commit-message"><a href="#一个普通的-commit-message" class="headerlink" title="一个普通的 commit message"></a>一个普通的 commit message</h2><p>为了让提交信息更有可读性，最早由 Angular 团队开发了语义化的提交信息写法。</p>
<p>一个语义化 Commit Message 的例子：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">feat(config): allow provided config object to extend other configs</span><br><span class="line"></span><br><span class="line">1. add service/user config</span><br><span class="line">2. add updated config object comment</span><br><span class="line"></span><br><span class="line">BREAKING CHANGE: `extends` key in config file is now used for extending other config files</span><br></pre></td></tr></tbody></table></figure>

<p>其格式可以归纳为：</p>
<blockquote>
<p>&lt;类型&gt;([影响的范围]): &lt; 简略的描述 &gt;</p>
<p>[正文：本次修改的详情]</p>
<p>[脚注]</p>
</blockquote>
<p>关于上面部分的介绍：</p>
<ul>
<li>类型<ul>
<li> feat：增加新功能。</li>
<li>fix：修正已有的 BUG。</li>
<li>其他：build, chore, ci, docs, style, refactor, perf, test 等。</li>
</ul>
</li>
<li>范围：应当是一个描述修改范围的名词，括号后应该有冒号。</li>
<li>简略描述：对代码变更的简短总结，以空格开头。</li>
<li>正文：多行，为代码变更提供额外的上下文信息，以空格与首行隔开。</li>
<li>脚注：多行，提交的元信息，如：Merge Request,Reviewer,Breaking Change…</li>
<li> 其他<ul>
<li>在首行的 <code>:</code> 号之前加入 <code>!</code> 号可以强调 BREAKING CHANGE。同时：脚注或者正文中必须包含: <code>BREAKING CHANGE: description</code></li>
</ul>
</li>
</ul>
<p>这样做的好处</p>
<ul>
<li>更清楚的表达变更的内容</li>
<li>使用工具自动化生成 CHANGELOG。</li>
<li>基于提交的类型，自动生成语义化版本号。</li>
<li>触发构建和部署流程（靠脚注和外部工具实现）。</li>
</ul>
<p>例 1: 一个复杂的 Commit Message</p>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">feat(api)!: new api: user-v2</span><br><span class="line"></span><br><span class="line">More detailed explanatory text, <span class="keyword">if</span> necessary.  Wrap it to </span><br><span class="line">about 72 characters or so. </span><br><span class="line"></span><br><span class="line">Further paragraphs come after blank lines.</span><br><span class="line"></span><br><span class="line">- support markdown</span><br><span class="line">- Use a hanging indent</span><br><span class="line"></span><br><span class="line">BREAKING CHANGE: isolate scope bindings definition has changed.</span><br><span class="line">    To migrate the code follow the example below:</span><br><span class="line">    Before:</span><br><span class="line">    scope: {</span><br><span class="line">      myAttr: <span class="string">'attribute'</span>,</span><br><span class="line">    }</span><br><span class="line">    After:</span><br><span class="line">    scope: {</span><br><span class="line">      myAttr: <span class="string">'@'</span>,</span><br><span class="line">    }</span><br><span class="line">    The removed `inject` was not generaly useful <span class="keyword">for</span> directives so there should be no code using it.</span><br><span class="line">Closes <span class="comment">#123, #245, #992</span></span><br></pre></td></tr></tbody></table></figure>

<p>例 2: 一个用于回滚代码的 Commit Message</p>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">revert: feat(user): abandon user api-v3</span><br><span class="line"></span><br><span class="line">This reverts commit 667ecc1654a317a13331b17617d973392f415f02</span><br></pre></td></tr></tbody></table></figure>

<h2 id="辅助工具、参考资料"><a href="#辅助工具、参考资料" class="headerlink" title="辅助工具、参考资料"></a>辅助工具、参考资料</h2><ul>
<li><a href="https://www.conventionalcommits.org/">Conventional Commits</a>： 语义化提交信息的社区网站。</li>
<li><a href="https://github.com/conventional-changelog/conventional-changelog">conventional-changelog</a>：一一个从 git 历史中解析出语义化提交信息的工具。</li>
<li><a href="https://github.com/olstenlarck/parse-commit-message">parse-commit-message</a>：解析工具，可以将提交信息的字符串解析成对象。</li>
<li><a href="https://github.com/autonomy/conform">conform</a>：用在 git 仓库上执行高级 hooks 的工具，也可以跟提交信息配合使用。</li>
<li><a href="https://github.com/conventional-changelog/standard-version">standard-version</a>：可以生成版本号和 CHANGELOG 的工具。</li>
<li><a href="https://github.com/commitsar-app/commitsar">commitsar</a>： 一个检查提交信息是否符合特定风格的工具。可在 CI 的 Docker 镜像中使用。</li>
</ul>
]]></content>
      <categories>
        <category>Git</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title>Moleculer, a modern microservices framework for NodeJS</title>
    <url>/posts/6122/</url>
    <content><![CDATA[<p>译自：<a href="https://medium.com/moleculer/moleculer-a-modern-microservices-framework-for-nodejs-bc4065e6b7ba">Moleculer Blog</a>，作者：<a href="https://medium.com/@icebob?source=post_header_lockup">Icebob</a>，发表时间：Jun 7, 2017</p>
<span id="more"></span>

<p><img src="https://cdn-images-1.medium.com/max/1600/1*NZkto85Cyh0zedAQsvu9tQ.png" alt="moleculer"></p>
<h2 id="Moleculer-Nodejs上现代化的微服务框架"><a href="#Moleculer-Nodejs上现代化的微服务框架" class="headerlink" title="Moleculer, Nodejs上现代化的微服务框架"></a>Moleculer, Nodejs 上现代化的微服务框架</h2><p>我宣布经过半年的努力，我为 Node.js 创造了一个全新的微服务框架。</p>
<h2 id="What‘s-Moleculer"><a href="#What‘s-Moleculer" class="headerlink" title="What‘s Moleculer"></a>What‘s Moleculer</h2><p>Moleculer 是一个开源的、快速的、可扩展的框架，基于 MIT 协议。它支持很多重要的微服务相关功能（服务注册，自动发现，负载均衡，断路器等）。</p>
<h2 id="Key-features"><a href="#Key-features" class="headerlink" title="Key features"></a>Key features</h2><ul>
<li>基于 Promise 的解决方案（Bluebird）</li>
<li>请求 - 响应的理念</li>
<li>事件驱动架构，支持负载均衡</li>
<li>支持中间件</li>
<li>内置缓存解决方案（内存，Redis）</li>
<li>支持多种传输器（TCP，NATS，MQTT，Redis，AMQP，NATS Streaming，Kafka）</li>
<li>支持多种序列化器（JSON，Avro，MsgPack，Protocol Buffer）</li>
<li>请求的负载均衡（round-robin，random）</li>
<li>自动发现服务</li>
<li>健康监测，指标和统计数据</li>
</ul>
<h2 id="Install"><a href="#Install" class="headerlink" title="Install"></a>Install</h2><p>通过 npm 包管理器可以安装 Moleculer，你可以使用 npm 或 yarn。</p>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">npm install moleculer</span><br></pre></td></tr></tbody></table></figure>

<h2 id="Usage"><a href="#Usage" class="headerlink" title="Usage"></a>Usage</h2><p>下面的这个小例子展示了使用 Moleculer 创建和调用服务有多简单。</p>
<figure class="highlight javascript"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> { ServiceBroker } = <span class="built_in">require</span>(<span class="string">"moleculer"</span>);</span><br><span class="line"><span class="comment">// Create broker</span></span><br><span class="line"><span class="keyword">let</span> broker = <span class="keyword">new</span> ServiceBroker({ <span class="attr">logger</span>: <span class="built_in">console</span> });</span><br><span class="line"><span class="comment">// Create a service</span></span><br><span class="line">broker.createService({</span><br><span class="line">    <span class="attr">name</span>: <span class="string">"math"</span>,</span><br><span class="line">    <span class="attr">actions</span>: {</span><br><span class="line">        <span class="comment">// You can call it as broker.call("math.add")</span></span><br><span class="line">        <span class="function"><span class="title">add</span>(<span class="params">ctx</span>)</span> {</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">Number</span>(ctx.params.a) + <span class="built_in">Number</span>(ctx.params.b);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">});</span><br><span class="line"><span class="comment">// Start broker</span></span><br><span class="line">broker.start();</span><br><span class="line"><span class="comment">// Call actions of service</span></span><br><span class="line">broker.call(<span class="string">"math.add"</span>, { <span class="attr">a</span>: <span class="number">5</span>, <span class="attr">b</span>: <span class="number">3</span> }).then(<span class="function"><span class="params">res</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="string">"5 + 3 ="</span>, res));</span><br></pre></td></tr></tbody></table></figure>

<p>正如所见，我们创建了一个 <code>math</code> 服务，有一个 <code>action</code> 叫 <code>add</code>。 这个 <code>action</code> 的作用是对两个参数求和。 创建后，我们可以使用 <code>broker.call</code> 方法调用它。<code>broker.call</code> 第一个参数是 <code>path（ervice name + action name）</code>，第二个参数是调用 <code>path</code> 指定的 <code>action</code> 需要的参数（需要包装成对象再传递）。</p>
<blockquote>
<p>在 Runkit 网站上，你可以在浏览器中运行上述代码。</p>
</blockquote>
<h2 id="Create-a-project"><a href="#Create-a-project" class="headerlink" title="Create a project"></a>Create a project</h2><p>使用 Molecular CLI 工具可以创建一个基于 Molecular 的微服务。</p>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment"># 1. 全局安装 moleculer-cli</span></span><br><span class="line">npm install moleculer-cli -g2.</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2. 创建一个新项目</span></span><br><span class="line">moleculer init project moleculer-demo</span><br></pre></td></tr></tbody></table></figure>

<blockquote>
<p>安装过程中，遇到提问全部选 Yes</p>
</blockquote>
<p>然后我们得到了一个 service（greeter），其中中包含基于 Jest 的测试，还有集成了 API 网关功能。</p>
<p>进入 <code>moleculer-demo</code> 的目录，启动</p>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> moleculer-demo</span><br><span class="line">npm run dev</span><br></pre></td></tr></tbody></table></figure>

<p>打开: <a href="http://localhost:3000/api/greeter/hello">http://localhost:3000/api/greeter/hello</a> 链接。它将会调用 greeter 服务的 helloaction.<br>打开: <a href="http://localhost:3000/api/greeter/welcome?name=world">http://localhost:3000/api/greeter/welcome?name=world</a> 链接将会调用 welcomeaction.</p>
<p>Congratulations！你成功创建了你的第一个 Moleculer 的微服务。欢迎打开微服务的大门。</p>
<p>如果你想了解更多关于 Moleculer 框架的知识，请查阅我们的网站 <a href="https://moleculer.services/">https://moleculer.services</a> 或者 github：<a href="https://github.com/moleculerjs/moleculer">https://github.com/moleculerjs/moleculer</a>.<br>你也可以在 Twitter 上关注我们 <a href="https://twitter.com/MoleculerJS">@MoleculerJS</a> 或者加入 <a href="https://gitter.im/moleculerjs/moleculer">Gitter</a> 同我们交流.</p>
<p>如果你喜欢这篇文章，可以在下方给我们点赞和留言。</p>
<p>完</p>
]]></content>
      <categories>
        <category>Node.js</category>
      </categories>
      <tags>
        <tag>Nodejs</tag>
        <tag>MicroService</tag>
        <tag>译文</tag>
      </tags>
  </entry>
  <entry>
    <title>团队建设：如何进行一次回顾会议</title>
    <url>/posts/21ff/</url>
    <content><![CDATA[<p>自己总结的关于如何开展一次回顾会议的要点。</p>
<span id="more"></span>

<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>本文目标</p>
<ol>
<li>写给没有 retrospective 经验的人看的参会指南</li>
<li>整理出 retrospective 中每个步骤的准备、行为、产出</li>
<li>关注每一个步骤中团队成员的心理状态</li>
<li>整理出一份组织者的实践策划方案</li>
</ol>
<p>Retrospective Meeting: 回顾会议。</p>
<p>指在一个开发周期之后，团队成员一起对这个周期的的办公室生活中的任何方面进行反馈，根据反馈的内容产出在下一个周期中执行的改进的回忆。</p>
<p>回顾会议强调每个人都能够无压力表达自己观点。<br>所以回顾会议会有一些能够让人放松的活动。<br>例如：破冰游戏。</p>
<p>一次完整的回顾会议有这样的步骤：</p>
<ul>
<li>准备<ul>
<li>发出一个通知给参与人员</li>
<li>准备用具（长度，便签等）</li>
<li>选一个 guide（本次会议的主持者）</li>
<li>破冰游戏</li>
<li>创造舒适的环境</li>
</ul>
</li>
<li>收集<ul>
<li>收集每个人的反馈，然后集中起来。</li>
</ul>
</li>
<li>讨论<ul>
<li>主持人带领大家 review 每条信息；</li>
<li>任何人可以发言，提出共鸣或者建议</li>
<li>有效的建议将被确定未 action</li>
</ul>
</li>
<li> 票选<ul>
<li>选出适当量的能够被执行的 action，分配一个 promoter</li>
<li> 在下一个周期中执行这些 action</li>
</ul>
</li>
<li>HAPPY ENDING<ul>
<li> 组织者将会议内容归纳存档</li>
</ul>
</li>
</ul>
<h2 id="实施策略"><a href="#实施策略" class="headerlink" title="实施策略"></a>实施策略</h2><h3 id="准备阶段"><a href="#准备阶段" class="headerlink" title="准备阶段"></a>准备阶段</h3><p>产出：创造轻松的会议环境，活跃的参会人</p>
<p>在会议开始之前提前一段时间通知团队成员，通知的内容包括：主题，时间，地点。</p>
<p>提前准备笔，便签，白板，会议室。</p>
<p>开始之后：选出主持人，为每个人分发便签。</p>
<p>主持人安排破冰（可选心态调查，回顾，游戏等）</p>
<pre><code>心态调查：调查参会者的心态是 ESVP 中的哪一种：Explorer：很有兴趣，想要探索；Shopper：逛超市来的，看看有没有好东西买；Vacationer：反正闲着也是闲着，来度个假；Prisoner：其实不想关在这里。使用便签来投票，如果热忱度不够建议取消会议
回顾：可以用一句话或者一个词描述自己在这个迭代的感受。也可以描述自己心情的变化。
游戏：使用游戏来激活大家
</code></pre>
<p>舒适性检查</p>
<pre><code>采用无记名投票的方式在便签上写下你想要请出这场会议的人。将最高得票的人请出会议。
</code></pre>
<h3 id="收集阶段"><a href="#收集阶段" class="headerlink" title="收集阶段"></a>收集阶段</h3><p>产出：可能多的反馈信息</p>
<p>给一定的时间让大家在便签上写这个周期的反馈，一条反馈一张便签。不记名。<br>写完卡片之后将便签张贴到白板上，白板分为 3 栏：Good，Not Good，Suggestion<br>反馈应该描述事实，尽量不加任何推断。</p>
<p>反馈的内容可以是这个周期内办公室生活的任何方面，以下是一些尝试性的思路</p>
<ul>
<li>项目的推进在一些事上很顺利</li>
<li>团队中发生了一些事让团队变得更好了</li>
<li>我学到了一些东西</li>
<li>我这段时间的状态很好，游刃有余</li>
<li>我这段时间遇到过一些困惑</li>
<li>我感受到被一些事影响了心情（效率，状态）</li>
<li>团队中一些工作进展的不太顺利</li>
<li>我觉得团队中如果有人来做某些事会更好</li>
</ul>
<p>以下是一些例子</p>
<p>G：Good；N：Not Good；S：Suggestion</p>
<ul>
<li><p>G，我们的服务到现在为止很稳定</p>
</li>
<li><p>G，任务板中的卡都被执行完了，进度超前！</p>
</li>
<li><p>G，广告账户系统刚刚完成了任务开发</p>
</li>
<li><p>G，当我思考问题时，换个环境能够帮助我理清思路</p>
</li>
<li><p>G，如果我在写代码之前就已经有了清晰的目标，那么我可以更快的完成</p>
</li>
<li><p>G，如果我在向别人表述之前首先描述一下背景，那么人们就更容易听懂表述的内容</p>
</li>
<li><p>G，在某个同学的催促下，空调在短时间被修好了</p>
</li>
<li><p>N，对于使用 git，我没有足够的自信</p>
</li>
<li><p>N，从 vs code 切换到 webStorm 导致我的效率变低了</p>
</li>
<li><p>N，拿到卡片之后，看了内容依旧不明白应该做什么</p>
</li>
<li><p>N，我搞砸了登陆服务，导致阿里云宕机</p>
</li>
<li><p>N，办公室的机械键盘太吵了</p>
</li>
<li><p>N，办公室的等在让人中午没办法入睡</p>
</li>
<li><p>N，不确定我写的 trello 卡片的描述是否合理</p>
</li>
<li><p>N，赵耀这段时间冷笑话减少了</p>
</li>
<li><p>N，今天的站会时间太长了</p>
</li>
<li><p>S，我觉得办公室空调温度应该定在 26 度以节约能源</p>
</li>
<li><p>S，我觉得每天都应该有下午茶</p>
</li>
</ul>
<h3 id="讨论"><a href="#讨论" class="headerlink" title="讨论"></a>讨论</h3><p>产出：改进方案</p>
<p>主持人朗读每一条信息，并将相同内容的便签粘贴在一起，归并整理。<br>大家可以对主持人朗读的内容发表意见 &amp; 评论，或是提出解决问题的方法；最后总结出应该做的改进。<br>主持人在白板上新开 action 一栏，将改进记录进去</p>
<h3 id="投票"><a href="#投票" class="headerlink" title="投票"></a>投票</h3><p>产出：下一个阶段可以被执行的 action</p>
<p>如果 action 数量过多，那么采用投票的方式选出要执行的 action，给 action 加上责任人</p>
<h2 id="HAPPY-ENDING"><a href="#HAPPY-ENDING" class="headerlink" title="HAPPY ENDING"></a>HAPPY ENDING</h2><p>将白板上的内容记录归纳存档，本轮的 action 将在下一轮回顾会议上收集阶段前 review 成效。</p>
<h2 id="破冰游戏"><a href="#破冰游戏" class="headerlink" title="破冰游戏"></a>破冰游戏</h2><p>例：逢 7 拍手</p>
<p>所有人围成一个圈依次报数。凡是每逢带 7 的数和 7 的倍数则不用报数，而是拍一下手表示过。动作慢的或是做错动作的则出局。</p>
]]></content>
      <categories>
        <category>Team-Build</category>
      </categories>
      <tags>
        <tag>Retrospective-Meeting(回顾会议)</tag>
      </tags>
  </entry>
</search>
